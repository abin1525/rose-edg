#if 0
// Use this to access the real A++ library
// (ultimately we have to include transformationMacros.h into A++.h)
#include "A++.h"
#include "transformationOptions.h"
#include "transformationMacros.h"
#else
// This contains a simpler A++ definition useful for fast compilation
#include "simpleA++.h"
#include "transformationOptions.h"
#include "transformationMacros.h"
#endif

#if 1
int
main ()
   {
     int i,j,k;
     int size = 10;
     doubleArray A(size);
     doubleArray B(size);

     for (i=0; i < size; i++)
          A(i+1,j+2,k+3) = B(i-0,j-3,k-2);

   }
#endif

#if 0
1) P++ Array Statement
     A = B;

2) P++ Array Statement with explicit communication
     A = B;
     A.updataGhostBoundaries();

3) A++ Array Statement
     A = B;

4) Scalar Indexing of A++ array object
     for (j=0; j < size; j++)
          for (i=0; i < size; i++)
               A(i,j) = B(i,j);

5) Effect of inlined scalar indexing operator
     for (j=0; j < size; j++)
          for (i=0; i < size; i++)
               A.data[i+(j*A.size1)] = B.data[i+(j*B.size1)];

6) Transformation using scalars instead of data members
     int Asize1 = A.size1;
     int Bsize1 = B.size1;
     double* restrict A_pointer = A.data;
     double* restrict B_pointer = B.data;
     for (j=0; j < size; j++)
          for (i=0; i < size; i++)
               A_pointer[i+(j*Asize1)] = B_pointer[i+(j*Bsize1)];

7) Transformation lifting loop invariant part of substript computation (likely generated by compiler
   from case 4)

     int Asize1 = A.size1;
     int Bsize1 = B.size1;
     double* restrict A_pointer = A.data;
     double* restrict B_pointer = B.data;
     double* temp_A_Pointer = A_Pointer+(j*Asize1);
     double* temp_B_Pointer = B_Pointer+(j*Bsize1);
     for (j=0; j < size; j++)
          for (i=0; i < size; i++)
               new_A_Pointer[i] = new_B_Pointer[i];

8) More highly optimized code not likely generated by compiler
     int Asize1 = A.size1;
     int Bsize1 = B.size1;
     double* restrict A_pointer = A.data;
     double* restrict B_pointer = B.data;
     for (j=0; j < size; j++)
        {
          double* temp_A_Pointer = A_Pointer+(j*Asize1);
          double* temp_B_Pointer = B_Pointer+(j*Bsize1);
          for (i=0; i < size; i++)
               *(temp_A_Pointer++) = *(temp_B_Pointer++);
        }
#endif










