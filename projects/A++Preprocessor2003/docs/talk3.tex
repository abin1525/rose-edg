\documentclass[10pt]{article}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}

% Fixme margin note package (turn on draft mode)
% \usepackage[final]{fixme}
% \usepackage[draft]{fixme}

\usepackage{color,listings}
\lstloadlanguages{APP}

\psfigdriver{dvips}

% New commands
\newcommand{\axx}{{\bf axx\ }}

\newcommand{\commentout}[1]{}

% change the title of the Fixme List
% \renewcommand{\listfixmename}{Things to Fix}

\newcommand{\comm}[2]{\bigskip
                      \begin{tabular}{|p{11cm}|}\hline
                      \multicolumn{1}{|c|}{{\bf Comment by #1}}\\ \hline
                      #2\\ \hline
                      \end{tabular}
                      \bigskip
                     }

\addtolength{\oddsidemargin}{-1.0in}
\addtolength{\evensidemargin}{-1.0in}
\addtolength{\textwidth}{2.0in}
\addtolength{\topmargin}{-0.5in}
\addtolength{\textheight}{1.5in}

% \pagenumbering{roman}
% \pagestyle{empty}
% \setcounter{page}{0}
% \thispagestyle{empty}

\sloppy

%---------------------------------------------------------------------
% Begin Document
%---------------------------------------------------------------------

\commentout{
   Outline for Talk

      Design of preprocessor
          AST
          Tree Traversal mechanism
          Queries
          Transformations

      Location of preprocessor

      Examples

 }

\begin{document}

\title{ \axx: An Introduction to the A++\/P++ Preprocessor \\ 
                      (DRAFT DOCUMENT) }
\author{Daniel J.\ Quinlan }
% {Center for Applied Scientific Computing\\
% Lawrence Livermore National Laboratory, Livermore, CA, USA\\
% }

\date{}

\maketitle

\tableofcontents

\pagenumbering{arabic}

\begin{abstract}

   This document introduces the initial release of the \axx preprocessor for A++\/P++ array class
library.  This work is made available under the policy of {\em release early and release often}.  While there
is much that \axx can do, there remains a significant amount of work to complete.  Within this
introduction we will cover the design of \axx, the location of the current release, how to control
the levels of optimization that can be introduced, examples of what \axx can do, and some of the
limitations of the current release.  Much more will come at a later point.

\end{abstract}

\lstset{
 % language=C++,
   language=APP,
 % basicstyle=\small,                 % print whole listing small
   basicstyle=\scriptsize,            % print whole listing scriptsize
 % keywordstyle=\color{red}\bfseries\underbar, % underlined bold red keywords
 % keywordstyle=\bfseries\underbar, % underlined bold red keywords
   keywordstyle=\color{red}\bfseries, % underlined bold red keywords
   ndkeywordstyle=\color{blue}, % underlined bold red keywords
 % rdkeywordstyle=\color{blue}, % underlined bold red keywords
   identifierstyle={},                % nothing happens to other identifiers
 % identifierstyle=\color{blue},                % nothing happens to other identifiers
   commentstyle=\color{green},                % nothing happens to other identifiers
 % stringstyle=\ttfamily,             % typerwriter type for strings
 % stringstyle=\color{cyan}\ttfamily,             % typerwriter type for strings Magenta
   stringstyle=\color{magenta}\ttfamily,             % typerwriter type for strings Magenta
   stringspaces=false,                % no special string spaces
   labelstyle=\scriptsize,
   labelstep=1,
   labelsep=10pt
}

\section{Introduction}

    The \axx preprocessor is an example of a preprocessor built using the ROSE compiler framework
and target the optimization of C++ applications using the A++\/P++ array class library.  The current
work only introduces serial transformations, parallel transformations will be introduced at a later
point.

    The A++\/P++ class library essentially represents the development of array abstractions in C++.
There are many serial array class libraries, but there are very few parallel array class libraries.
Applications developed using the A++ (serial) array class library can be recompiled to run in parallel
on distributed memory machines using the P++ (parallel) array class library.  The purpose of \axx is to
provide for optimizations that are not possible by the conventional C++ compiler.  \axx acts as a compiler,
but is really a source-to-source preprocessor that will call the backend C++ compiler automatically (after
preforming source-to-source transformations.  The generated code containing the transformations is not hidden
from the user and is placed in the same directory as the object file but with the prefix {\tt rose\_}.


Example A++\/P++ array statements:

\vspace{0.5in}

\begin{figure}[tb]
\begin{center}
\begin{tabular}{|c|} \hline
 Example Code \\\hline\hline
\begin{lstlisting}{}

  // Simple array statement
     A = 0;
     A(I) = B(J);

  // Simple array stencil
     A(I,J) = A(I-1,J) + A(I+1,J) + A(I,J-1) + A(I,J+1);

\end{lstlisting}
\\\hline
\end{tabular}
\end{center}
\caption{ Example code used to generate AST. }
\label{AST_Code}
\end{figure}

% \newpage
\section{The Design of Preprocessors}

    The design of the \axx preprocessor follows the general design of all preprocessor built using the
ROSE compiler framework. We expect that a final verison of \axx should be quite small, but at present
the implementation includes numerous features that will be moved into ROSE at some point.

\subsection{Abstract Syntax Tree (AST)}

     A general feature of the internal design of modern compilers is the representation of the
program as an abstract syntax tree (AST).  The AST is in general not really a tree, but a graph of
how pieces of the program are decomposed in terms of a languages grammar.  Figure \ref{AST_Graph} shows and
example AST for a trivial program shown in figure \ref{AST_Code}.

\begin{figure}[tb]
\begin{center}
\begin{tabular}{|c|} \hline
 Example Code \\\hline\hline
\begin{lstlisting}{}

int main() {
  int a[10];

  for(int i=0; i < 10; i++)
    a[i] = i * i;

  return 0;
}

\end{lstlisting}
\\\hline
\end{tabular}
\end{center}
\caption{ Example code used to generate AST. }
\label{AST_Code}
\end{figure}

\begin{figure}[h]
\begin{center}
\begin{tabular}{|c|} \hline
 Abstract Syntax Tree \\\hline\hline
\includegraphics[scale=0.9]{AST.ps}
\\\hline
\end{tabular}
\end{center}
\caption{AST representing example code. }
\label{AST_Graph}
\end{figure}

% \pagebreak


\subsection{Tree Traversal}

    A key piece of ROSE is the tree traversal mechanism, a collection of functions which take global
function pointers and execute the associated global functions on each of the nodes of the AST and
then call the respective traversal mechanism for all sucessor nodes.  In this way the global
functions are executed on all nodes of the AST in a predefined order.

% \begin{figure}[h]
% \begin{center}
% \begin{tabular}{|c|} \hline
%  Tree Traversal Interface \\\hline\hline
\begin{lstlisting}{}

// Declaration of attribute types
class InheritedAttributeType_Instrument {};
class SynthesizedAttributeType_Instrument {};
class AccumulatorType_Instrument {};

// Declaration of treeTraversal object
SgTreeTraversal<InheritedAttributeType_Instrument, 
                SynthesizedAttributeType_Instrument,
                AccumulatorType_Instrument>
     treeTraversal (initializationFunction, localFunction, assemblyFunction, modifyAccumulatorFunction);

// Call the tree traversal function on a project (a project consists of one or more files)
treeTraversal.traverseInputFiles(&sageProject, inheritedValue, accumulatorValue, postorder, FALSE);

\end{lstlisting}
% \\\hline
% \end{tabular}
% \end{center}
% \caption{ Tree Traversal Interface Example Code }
% \label{TreeTraversalInterfaceCode}
% \end{figure}


\subsection{Query Mechanism}

    The query mechanism is intimately associated with the tree traversal mechanism and represents
the interface of the tree traversal mechanism and the global functions that are executed on each
node.  Using approaches defined by attribute grammars, there are two different types of attributes:
inherited attributes and synthesized attributes.   Within the current work we also add 
what we refer to as an {\em accumulator attribute}, but this is not a conventional feature of
attribute grammars and may be removed.

\begin{itemize}
     \item {\bf Inherited Attributes} \\ Attributes represent values made available to
           subtrees. They are copied on each node from the parent to the child. If a parent modifies
           the inherited attribute it is see only by the children (and by recursion the whole
           subtree). These may be used as part of a pre-order or post-order traversal of the AST.

     \item {\bf Synthesized attributes} \\ Synthesized attributes are constructed from the child
           attributes on the way back up through the tree within the postored tree traversal. Any
           possible synthesised attributes from children (successor nodes) are assembled into a
           single synthesized attribute and passed to parent nodes in the AST traversal (within the
           post-order traveral of the AST).

     \item {\bf Accumulator attributes} \\ Attributes that are accessible from any point in the tree
           traversal, essentially global variables made available to all nodes of the AST.
\end{itemize}

% \newpage
\subsection{Specification of Transformations}

    The \axx preprocessor uses the transformation specification mechanism defined within ROSE. These
mechanisms permit the specification of ascii text strings as a way to specify source code.  These
strings are assembled into intermediate program files internally and run through the front-end to
generate the AST fragments that the compiler understands.  Internally the compiler doesn't
understand strings, but only graphs (the AST), so the strings are converted to subgraphs.  The final
insertion/substitution of the transformation occurs as editing of the graph representing the AST.

A simple set of member functions at each node of the AST permit the editing of the AST using ascii strings to
specify new code to be generated.  Since any new code generated for use internally to edit the AST must be compiled to
generate an AST fragement, this process requires all local declarations and global declarations to compile properly.

AST editing functions available at each node of the AST include:
\begin{itemize}
    \item {\tt {\bf appendSourceCode} ( SgProject* project, string sourceCode, 
                             string localDeclarations, string globalDeclarations, bool isADeclaration);}
    \item {\tt {\bf prependSourceCode} ( SgProject* project, string sourceCode, 
                             string localDeclarations, string globalDeclarations, bool isADeclaration);}
    \item {\tt {\bf replaceSourceCode} ( SgProject* project, string sourceCode, 
                             string localDeclarations, string globalDeclarations, bool isADeclaration);}
    \item {\tt {\bf insertSourceCode} ( SgProject* project, string sourceCode, 
                             string localDeclarations, string globalDeclarations, bool locateNewCodeAtTop, bool isADeclaration);}
\end{itemize}

   In these member functions, the SgProject object contains the list of files to be processed and
information such as the input commandline which is reused for compiling intermediate generated files
(to generate AST fragments).  The {\tt string} objects represent the ascii source code associated with the
transformation's source code, and its supporting local declarations and global declarations.  Global declarations
include the ``\#include'' declarations required to read head all header files required for compiling the transformation.

The following code shows an example of an intermediate file generated internally.  This file is compiled using the 
commandline arguments input to \axx (the same commandline that the user has specified for compiling his application).
The AST generated from the compilation of this intermediate file is processed internally to extract out its relavant parts.
The AST fragments extracted are then inserted into the application program's AST using the AST editing functions presented in 
previously.

   The following example file is internally generated and is never seen by the user (though it is
not deleted by the preprocessor phases). It is assembled from the source code strings input to the
AST editing functons.

\vspace{0.5in}

\begin{lstlisting}{}

// ################################################################
// THIS IS AN AUTOMATICALLY GENERATED FILE (DO NOT EDIT THIS FILE!)
// ################################################################

#include "simpleA++.h" 
#define ROSE_MACROS_APPEAR_AS_FUNCTIONS 
#include "transformationMacros.h" 

// Variables used in this transformation (automatically generated from simple dependence analysis of original code before transformation) 
Range I; 
Range J; 
double Mesh_Size; 
doubleArray Right_Hand_Side; 
doubleArray Solution; 


doubleArray _T;int SC_Right_Hand_Side_I_J(int,int); int SC_Solution_I_J(int,int); int SC__T_I_J(int,int); int _Right_Hand_Side; int _Right_Hand_Side_I_J; int _Solution; int _Solution_I_J; int __T; int __T_I_J; 

int
transformationContainerFunction() 
   {
          // Automatically Introduced Transformation (via preprocessor built by ROSE)
          // { 
          // These loop index declarations could later be declared just once in the same scope as the statement being transformed 
          int VARIABLE_DECLARATIONS_MARKER_START; 
             ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(_Right_Hand_Side);
             ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(_Solution);
             ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(__T);
             double* APP_RESTRICT _Right_Hand_Side_I_J_pointer = NULL;
             double* APP_RESTRICT _Solution_I_J_pointer = NULL;
             double* APP_RESTRICT __T_I_J_pointer = NULL;
          ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(_Right_Hand_Side_I_J);
          ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(_Solution_I_J);
          ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(__T_I_J);
          LOOP_INDEX_VARIABLES_DECLARATION_MACRO_D2();
           
          int VARIABLE_DECLARATIONS_MARKER_END; 
          int VARIABLE_INITIALIZATION_MARKER_START; 
          // undef subscript computation macro (before transformation) 
           
             "ROSE-TRANSFORMATION-MACRO:#define SC_Right_Hand_Side_I_J(x1,x2) /* case VariableSizeVariableStride */ \                  (x1)*_Right_Hand_Side_I_J_stride1+((x2)*_Right_Hand_Side_I_J_stride2*_Right_Hand_Side_size1)"; 
             "ROSE-TRANSFORMATION-MACRO:#define SC_Solution_I_J(x1,x2) /* case VariableSizeVariableStride */ \
                  (x1)*_Solution_I_J_stride1+((x2)*_Solution_I_J_stride2*_Solution_size1)"; 
             "ROSE-TRANSFORMATION-MACRO:#define SC__T_I_J(x1,x2) /* case VariableSizeVariableStride */ \
                  (x1)*__T_I_J_stride1+((x2)*__T_I_J_stride2*__T_size1)"; 
             ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(Right_Hand_Side,_Right_Hand_Side);
             ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(Solution,_Solution);
             ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(_T,__T);
             _Right_Hand_Side_I_J_pointer = Right_Hand_Side.getAdjustedDataPointer(I,J); 
             _Solution_I_J_pointer = Solution.getAdjustedDataPointer(I,J); 
             __T_I_J_pointer = _T.getAdjustedDataPointer(I,J); 
          ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(Right_Hand_Side,_Right_Hand_Side_I_J);
          ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(Solution,_Solution_I_J);
          ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(_T,__T_I_J);
          ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(Solution);
           
          int VARIABLE_INITIALIZATION_MARKER_END; 
          int TRANSFORMATION_MARKER_START; 
          _T.redim(Solution);
          // "for" loop for $dimD array operations with stride 
             for (_2 = 0; _2 < _length2; _2++) { 
             for (_1 = 0; _1 < _length1; _1++) { 
                __T_I_J_pointer[SC__T_I_J(_1,_2)] = 
                     ((((((((((Mesh_Size*Mesh_Size*
                     _Right_Hand_Side_I_J_pointer[SC_Right_Hand_Side_I_J(_1,_2)])+
                     _Solution_I_J_pointer[SC_Solution_I_J((_1+1),_2)])+
                     _Solution_I_J_pointer[SC_Solution_I_J((_1-1),_2)])+
                     _Solution_I_J_pointer[SC_Solution_I_J(_1,(_2+1))])+
                     _Solution_I_J_pointer[SC_Solution_I_J(_1,(_2-1))])+
                     _Solution_I_J_pointer[SC_Solution_I_J((_1+1),(_2+1))])+
                     _Solution_I_J_pointer[SC_Solution_I_J((_1+1),(_2-1))])+
                     _Solution_I_J_pointer[SC_Solution_I_J((_1-1),(_2+1))])+
                     _Solution_I_J_pointer[SC_Solution_I_J((_1-1),(_2-1))])/8.0); 
                } 
                } 
          // "for" loop for $dimD array operations with stride 
             for (_2 = 0; _2 < _length2; _2++) { 
             for (_1 = 0; _1 < _length1; _1++) { 
                _Solution_I_J_pointer[SC_Solution_I_J(_1,_2)] = __T_I_J_pointer[SC__T_I_J(_1,_2)]; 
                } 
                } 
           
          int TRANSFORMATION_MARKER_END; 
          // }
           
     return 0;
   }

\end{lstlisting}


\subsection{Example Preprocessor: Instrumentation}

   This example preprocessor is a complete compiler which takes in a C++ source code and outputs and
object file (or executable) just like any other compiler.  In this case the goal of the
transformations are to instrument the code.  The instrumentation consists of adding a function call,
to {\tt myTimerFunctionStart()}, to a top of each block (scope) and a function call, to {\tt
myTimerFunctionEnd()}, to the bottom of each block (scope).  

\commentout{
Inorder to be compleatly
self-contained, and additional transformation inserts the definitions of {\tt
myTimerFunctionStart()} and {\tt myTimerFunctionEnd()} at the top fo the program (just before the
{\tt main()} function).
}

   The definitions of the functions and the function call statements consist of ascii strings and
are inserted into the AST using the AST method functions {\tt prependSourceCode} and {\tt
insertSourceCode}.  This simplified approach to the editing of the AST is a new and novel feature of
the ROSE compiler framework (it is not done by any other compiler that I'm aware of) and is an
example of how we simplify the specification of transformations to make them accessable to library
developers and others without an extensive compiler background.

\vspace{0.5in}

\begin{lstlisting}{}

// ROSE is a tool for building preprocessors, this file is an example preprocessor built with ROSE.
// Specifically it shows the design of a transformation to instrument source code, placing source code
// at the top and bottome of each basic block.

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "rose.h"
#include "Cxx_GrammarTreeTraversalClass.h"

// this is required as a way to hand the SgProject to the prependSourceCode, 
// appendSourceCode, replaceSourceCode, and insertSourceCode functions.
SgProject* globalProject = NULL;

class InheritedAttributeType_Instrument {};
class SynthesizedAttributeType_Instrument {};
class AccumulatorType_Instrument {};


SynthesizedAttributeType_Instrument
initializationFunction()
   {
     return SynthesizedAttributeType_Instrument();
   }

void
modifyAccumulatorFunction(AccumulatorType_Instrument& a)
   {
   }

SynthesizedAttributeType_Instrument
localFunction(
     SgNode* astNode,
     InheritedAttributeType_Instrument& inheritedValue,
     AccumulatorType_Instrument& accumulatorValue)
   {
     return SynthesizedAttributeType_Instrument();
   }

SynthesizedAttributeType_Instrument
assemblyFunction(
     SgNode* astNode,
     InheritedAttributeType_Instrument & inheritedValue,
     vector<SynthesizedAttributeType_Instrument> synthesizedAttributeList,
     AccumulatorType_Instrument & accumulatorValue)
   {
     if (astNode->variant() == BASIC_BLOCK_STMT)
        {
          const int SIZE_OF_BLOCK = 0;
       // Only instrument blocks with more then 10 statements (a poor metric of computational intensity)
          if (isSgBasicBlock(astNode)->get_statements().size() > SIZE_OF_BLOCK)
             {
               char* globalDeclarations = "void myTimerFunctionStart(); void myTimerFunctionEnd();";
	       char* localDeclarations   = "";
               char* codeAtTopOfBlock    = "myTimerFunctionStart();";
               char* codeAtBottomOfBlock = "myTimerFunctionEnd();";

            // Build a new AST fragment and insert it into the AST
               bool locateNewCodeAtTop = TRUE;
               bool isADeclaration = FALSE;
               astNode->insertSourceCode(*globalProject,codeAtTopOfBlock,
                                         localDeclarations,globalDeclarations,
                                         locateNewCodeAtTop,isADeclaration);
               locateNewCodeAtTop = FALSE;
               astNode->insertSourceCode(*globalProject,codeAtBottomOfBlock,
                                         localDeclarations,globalDeclarations,
                                         locateNewCodeAtTop,isADeclaration);
             }
        }

     return SynthesizedAttributeType_Instrument();
   }

int
main ( int argc, char * argv[] )
   {
  // Build the project object which we will fill up with multiple files and use as a
  // handle for all processing of the AST(s) associated with one or more source files.
     int EDG_FrontEndErrorCode = 0;
     SgProject sageProject (argc,argv,EDG_FrontEndErrorCode);

  // Warnings from EDG processing are OK but not errors
     ROSE_ASSERT (EDG_FrontEndErrorCode <= 3);

  // This is the way we pass in the project that our query requires (temporary code)
     globalProject = &sageProject;

  // We need these until we have a new interface which will allow us to skip them (they are not used)
     InheritedAttributeType_Instrument inheritedValue;
     AccumulatorType_Instrument        accumulatorValue;

     SgTreeTraversal<InheritedAttributeType_Instrument, SynthesizedAttributeType_Instrument, AccumulatorType_Instrument>
          treeTraversal (initializationFunction, localFunction, assemblyFunction, modifyAccumulatorFunction);

     treeTraversal.traverseInputFiles(&sageProject, inheritedValue, accumulatorValue, postorder, FALSE);

  // Generate the final C++ source code from the potentially modified SAGE AST
     sageProject.unparse();

  // What remains is to run the specified compiler (typically the C++ compiler) using the
  // generated output file (unparsed and transformed application code) to generate an object file.
     int finalCombinedExitStatus = sageProject.compileOutput();

  // return any errors generated by the backend compilation of the modified source code
     return finalCombinedExitStatus;
   }

\end{lstlisting}

\vspace{0.5in}

   Running the instrumentation preprocessor on the following example code:

\begin{lstlisting}{}

int
main ( int argc, char * argv[] )
   {
     int boolean;
     int n = 100;
     if (boolean)
        {
          int x;
          int y;
	  for (int i=0; i < n; i++)
	     {
               int x;
               int y;
	     }
        }
       else
        {
          int y;
          int z;
        }
     
     return 0;
   }

\end{lstlisting}

\vspace{0.5in}

generates the instrumented code show below:

\begin{lstlisting}{}

int main(int argc,char * * argv)
   { 
     myTimerFunctionStart();
     int boolean; 
     int n = 100; 
     if (boolean)
        { 
          myTimerFunctionStart();
          int x; 
          int y; 
          for (int i = 0; i < n; i++)
             { 
               myTimerFunctionStart();
               int x; 
               int y; 
               myTimerFunctionEnd(); 
             } 
          myTimerFunctionEnd(); 
        } 
       else
        { 
          myTimerFunctionStart();
          int y; 
          int z; 
          myTimerFunctionEnd(); 
        } 
     myTimerFunctionEnd();
     return 0;
  }

\end{lstlisting}


\section{A Tour of Code from the \axx Preprocessor}

   A more complex example showing a more sophisticated use of ROSE is in the implementation
of the \axx preprocessor.  We show two of the functions from the implementation of \axx.
These examples show the use of the inherited, synthesised, and accumulator attributes.

   The \axx will eventually have many different transformations, the design presently contains an
array transformation mechanism which was only one transformation implemented; the {\bf {\it array assignment
statement transformation}}. Additional transformations will be added and include:

\begin{itemize}
     \item {\bf Scalar Indexing Transformation} \\ Used to optimize the use of scalar indexing of
     A++\/P++ array objects where possible.

     \item {\bf Parallel Message Scheduling Transformations} \\ The generation of MPI calls can be moved/aggregated to optimze parallel communication.
\end{itemize}

   Within the {\it array assignment statement transformation} within the \axx preprocessor we use all three froms of attributes.
\begin{itemize}
     \item {\bf Inherited Attributes} \\ Used to communicate if array operand are indexed.  If they
           are indexed then it is set in the inherited attribute so that it can be read in the
           assemble function on the way back up the tree.  This communicates to the processing of
           the variable reference case within the assembly function that it does not have to
           complete the substring processing (since it will be compled by the processing of the
           index arguments later).

     \item {\bf Synthesized attributes} \\ Synthesized attributes are used to carry the assemble
           pieces of the trnasformation back up the tree (the transformations are separated into
           declarations, initializations, and the specification).  This is a part of the post-order
           traversal of the tree.

     \item {\bf Accumulator attributes} \\ An accumulator attribute is used (referenced on each
           node, essentially like a global variable) to hold the operand data base which stores the
           names of the operands and an index database for each operand (containing the names of the
           index objects used for that operand).
\end{itemize}

The following sections present the example code used within the local function and assembly function
to generate and manipulate these attributes.

\subsubsection{Local Attribute Generation Function from Array Assignment Statement Tranformation}

    This example is extracted from the \axx A++\/P++ Preprocessor.  It is a local function computed
as part of the query to generate the assignment statement transformation (example of which are
provided at the end of this document).  The function is called using the global tree traversal
mechanism on each node as part of a preorder traversal of the AST.  The sole purpose of the function
is to mark the inherited attribute at any AST node representing an doubleArray::operator() member
function call as indexed.  Note the call to:

        {\tt arrayAssignmentStatementQueryInheritedData.setIsIndexedArrayOperand(TRUE); }

which marks the inherited attribute so that the subtree's traversal of the will know the context of its setting
in the array statement.

\vspace{0.5in}

\begin{lstlisting}{}

ArrayAssignmentStatementQuerySynthesizedAttributeType
localArrayAssignmentStatementQueryFunction (
   SgNode* astNode,
   ArrayAssignmentStatementQueryInheritedAttributeType & arrayAssignmentStatementQueryInheritedData, 
   ArrayAssignmentStatementQueryAccumulatorType        & accumulatorValue )
   {
     ArrayAssignmentStatementQuerySynthesizedAttributeType returnSynthesizedAttribute;

  // Default value for synthesized attribute we will use as a return value
     returnSynthesizedAttribute.setTransformationSourceCode("");

     switch (astNode->variant())
        {
          case FUNC_CALL: // tag for SgFunctionCallExp class
             {
               SgFunctionCallExp* functionCallExpression = isSgFunctionCallExp(astNode);
               ROSE_ASSERT (functionCallExpression != NULL);

               string operatorName = ArrayTransformationSupport::getFunctionName ( functionCallExpression );

               SgType* functionType = functionCallExpression->get_type();
               string functionTypeName = ArrayTransformationSupport::getTypeName (functionType);

               if ( (functionTypeName != "doubleArray") && (functionTypeName != "floatArray") && (functionTypeName != "intArray") )
                  {
                 // Use this query to handle only A++ function call expressions
                    returnSynthesizedAttribute.setTransformationSourceCode("");
                    break;
                  }

               ROSE_ASSERT ( (functionTypeName == "doubleArray") || 
                             (functionTypeName ==  "floatArray") ||
                             (functionTypeName ==    "intArray") );

               ArrayTransformationSupport::operatorCodeType operatorCodeVariant =
                    ArrayTransformationSupport::classifyOverloadedOperator (operatorName.c_str());

            // Separating this case into additional cases makes up to some 
            // extent for using a more specific higher level grammar.
               switch (operatorCodeVariant)
                  {
                    case ArrayTransformationSupport::PARENTHESIS_OPERATOR_CODE:
                       {
                         ROSE_ASSERT (operatorName == "operator()");

                      // Record that the array operand is index with InternalIndex objects this info
                      // is used later in the assembly phase to defer the specification of return string.
                         arrayAssignmentStatementQueryInheritedData.setIsIndexedArrayOperand(TRUE);
                         break;
                       }
                  }
             }
        }

     return returnSynthesizedAttribute;
   }

\end{lstlisting}

\subsubsection{Assembly function from Array Assignment Statement Tranformation}

The assembly function takes attributes generated by the local function and generates from child
synthesized attributes a single synthesized attribute (hense the name {\bf synthesized attribute}).

\vspace{0.5in}

{\scriptsize
\begin{lstlisting}{}

ArrayAssignmentStatementQuerySynthesizedAttributeType
arrayAssignmentStatementQueryAssemblyFunction (
   SgNode* astNode,
   ArrayAssignmentStatementQueryInheritedAttributeType & arrayAssignmentStatementQueryInheritedData, 
   vector<ArrayAssignmentStatementQuerySynthesizedAttributeType> synthesizedAttributeList,
   ArrayAssignmentStatementQueryAccumulatorType        & accumulatorValue )
   {
  // This function assembles the elements of the input list (a list of char*) to form the output (a single char*)

  // Make a reference to the global operand database
     OperandDataBaseType & operandDataBase = accumulatorValue.operandDataBase;

  // Build the return value for this function
     ArrayAssignmentStatementQuerySynthesizedAttributeType returnSynthesizedAttribute;

  // Build up a return string
     string returnString;

  // Default setting for offsetString
     string offsetString = "_1,_2,_3,_4,_5,_6";

  // Figure out the dimensionality of the statement globally
     int maxNumberOfIndexOffsets = 6; // default value for A++/P++ arrays
     ROSE_ASSERT (arrayAssignmentStatementQueryInheritedData.arrayStatementDimensionDefined == TRUE);
     if (arrayAssignmentStatementQueryInheritedData.arrayStatementDimensionDefined == TRUE)
        {
       // The the globally computed array dimension from the arrayAssignmentStatementQueryInheritedData
          maxNumberOfIndexOffsets = arrayAssignmentStatementQueryInheritedData.arrayStatementDimension;

       // reset the offsetString since the maxNumberOfIndexOffsets is less than the A++/P++ MAX_ARRAY_DIMENSION
          offsetString = "";
          int n = 0;
          char countString[128];
          for (n = 0; n < maxNumberOfIndexOffsets; n++)
             {
            // Add the different expressions represented by the indexing strings together
               if ( n > 0 )
                    offsetString += ",";
               offsetString += "_" + StringUtility::numberToString(n+1);
             }
        }

     vector<ArrayAssignmentStatementQuerySynthesizedAttributeType>::iterator i;

     string operatorString;

     switch (astNode->variant())
        {
       // Need to handle prefix and postfix unary operators
          case UNARY_MINUS_OP:
          case UNARY_ADD_OP:
          case NOT_OP:
          case DEREF_OP:
          case ADDRESS_OP:
          case MINUSMINUS_OP:
          case PLUSPLUS_OP:
          case UNARY_EXPRESSION:
             {
            // printf ("Found a UNARY expression (not implemented!) \n");
               SgUnaryOp*   unaryOperator  = isSgUnaryOp(astNode);
               ROSE_ASSERT (unaryOperator != NULL);

               returnString = " $UNARY_OP$ ";

               operatorString = ArrayTransformationSupport::buildOperatorString (astNode);

            // This is example of where it is useful to have enums generated from non-terminals within ROSETTA
               string operandString = synthesizedAttributeList[SgUnaryOp_operand_i].getTransformationSourceCode();

            // This does not handle prefix and postfix operators properly
               returnString = operatorString + operandString;

               returnSynthesizedAttribute.setTransformationSourceCode(returnString);
               break;
             }

       // Handle binary operators
          case ADD_OP:
          case SUBT_OP:
          case MULT_OP:
          case DIV_OP:
          case INTEGER_DIV_OP:
          case MOD_OP:
          case AND_OP:
          case OR_OP:
          case BITXOR_OP:
          case BITAND_OP:
          case BITOR_OP:
          case EQ_OP:
          case LT_OP:
          case GT_OP:
          case NE_OP:
          case LE_OP:
          case GE_OP:
          case ASSIGN_OP:
          case BINARY_EXPRESSION:
             {
            // printf ("Found a BINARY OPERATOR expression \n");

               operatorString = ArrayTransformationSupport::buildOperatorString (astNode);

            // Handle the special assembly of binary operators
               SgBinaryOp*  binaryOperator = isSgBinaryOp(astNode);
               ROSE_ASSERT (binaryOperator != NULL);

               returnString = synthesizedAttributeList[SgBinaryOp_lhs_operand_i].getTransformationSourceCode() +
                              operatorString +
                              synthesizedAttributeList[SgBinaryOp_rhs_operand_i].getTransformationSourceCode();

               returnSynthesizedAttribute.setTransformationSourceCode(returnString);
               break;
             }

          case EXPR_STMT:
             {
            // The assembly associated with the SgExprStatement is what 
            // triggers the generation of the transformation string
               SgExprStatement* expressionStatement = isSgExprStatement(astNode);
               ROSE_ASSERT (expressionStatement != NULL);

               ArrayAssignmentStatementQuerySynthesizedAttributeType innerLoopTransformation =
                    synthesizedAttributeList[SgExprStatement_expression_root];

            // Make sure that the indexing computation macro has been edited away
               ROSE_ASSERT ( innerLoopTransformation.getTransformationSourceCode().find("INDEXING_SUBSCRIPT_COMPUTATION") == npos );

            // Verify that we have a valid string
               ROSE_ASSERT (innerLoopTransformation.getTransformationSourceCode().length() > 0);

            // Call another global support
               returnSynthesizedAttribute =
                    expressionStatementTransformation (
                         expressionStatement,
                         arrayAssignmentStatementQueryInheritedData,
                         innerLoopTransformation,
                         operandDataBase );

            // Verify that we have a valid string
               ROSE_ASSERT (returnSynthesizedAttribute.getTransformationSourceCode().length() > 0);

            // Verify that we have saved the variable declarations
               ROSE_ASSERT (returnSynthesizedAttribute.getVariableDeclarationStrings().size() > 0);
               break;
             }

          case EXPR_LIST:
             {
            // Most overloaded function accept their lhs and rhs within the parameter list
            // (e.g. friend T operator+(T lhs,T rhs) or T T::operator=(T rhs) for a type of class T)

            // To figure out how to handle the the expression list we need to figure out
            // if it is an expression list from an overloaded function from A++/P++.

               SgExprListExp* exprListExp = isSgExprListExp( astNode );
               ROSE_ASSERT (exprListExp != NULL);

            // Get the parent and check if it is an overloaded operator
               SgExpression* parentExpression = exprListExp->get_parent();
               ROSE_ASSERT (parentExpression != NULL);

               switch ( parentExpression->variant() )
                  {
                    case FUNC_CALL:
                       {
                         SgFunctionCallExp* functionCallExpression = isSgFunctionCallExp(parentExpression);
                         ROSE_ASSERT (functionCallExpression != NULL);

                      // Get the name of the parent function
                         string operatorName = ArrayTransformationSupport::getFunctionName ( functionCallExpression );
                         ROSE_ASSERT (operatorName.c_str() != NULL);

                      // Get the value of the offsets (start the search from the functionCallExp)
                         SgExprListExp* exprListExp = functionCallExpression->get_args();
                         ROSE_ASSERT (exprListExp != NULL);

                         SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
                         int numberOfParameters = expressionPtrList.size();

                      // Classify the function name (it could be an overloaded function)
                         ArrayTransformationSupport::operatorCodeType operatorCodeVariant =
                              ArrayTransformationSupport::classifyOverloadedOperator
                                   (operatorName.c_str(),numberOfParameters);

                         switch (operatorCodeVariant)
                            {
                           // case of sin, cos, pow, etc.
                           // normal function call (not an overloaded operator function) (used as the default value)
                              case ArrayTransformationSupport::FUNCTION_CALL_OPERATOR_CODE:
                                   ROSE_ASSERT (synthesizedAttributeList.size() == 1);
                                   returnString = synthesizedAttributeList[0].getTransformationSourceCode();
                                   int n;
                                   for (n = 1; n < synthesizedAttributeList.size(); n++)
                                      {
                                     // concatenate the synthesized attributes
                                        returnString = returnString + string(",") + synthesizedAttributeList[n].getTransformationSourceCode();
                                      }
                                   returnString = string("$OPERATOR(") + returnString + string(")");
                                   break;

                              case ArrayTransformationSupport::PARENTHESIS_OPERATOR_CODE:
                                   returnString = "";
                                   for (i = synthesizedAttributeList.begin(); i != synthesizedAttributeList.end(); i++)
                                      {
                                     // concatenate the synthesized attributes
                                        returnString = returnString + (*i).getTransformationSourceCode();
                                      }
                                   break;

                              case ArrayTransformationSupport::ASSIGN_OPERATOR_CODE:
                                   ROSE_ASSERT (synthesizedAttributeList.size() == 1);
                                   returnString = "$OPERATOR" + synthesizedAttributeList[0].getTransformationSourceCode();
                                   break;

                           // Overloaded binary operators: These are implemented a friend functions taking 2
                           // parameters instead of member functions taking only 1 parameter, as a result they
                           // have to be handled differently.
                              case ArrayTransformationSupport::ADD_OPERATOR_CODE:
                              case ArrayTransformationSupport::SUBT_OPERATOR_CODE:
                              case ArrayTransformationSupport::MULT_OPERATOR_CODE:
                              case ArrayTransformationSupport::DIV_OPERATOR_CODE:
                              case ArrayTransformationSupport::INTEGER_DIV_OPERATOR_CODE:
                              case ArrayTransformationSupport::MOD_OPERATOR_CODE:
                              case ArrayTransformationSupport::AND_OPERATOR_CODE:
                              case ArrayTransformationSupport::OR_OPERATOR_CODE:
                              case ArrayTransformationSupport::BITXOR_OPERATOR_CODE:
                              case ArrayTransformationSupport::BITAND_OPERATOR_CODE:
                              case ArrayTransformationSupport::BITOR_OPERATOR_CODE:
                              case ArrayTransformationSupport::EQ_OPERATOR_CODE:
                              case ArrayTransformationSupport::LT_OPERATOR_CODE:
                              case ArrayTransformationSupport::GT_OPERATOR_CODE:
                              case ArrayTransformationSupport::NE_OPERATOR_CODE:
                              case ArrayTransformationSupport::LE_OPERATOR_CODE:
                              case ArrayTransformationSupport::GE_OPERATOR_CODE:
                              case ArrayTransformationSupport::PLUS_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::MINUS_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::AND_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::IOR_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::MULT_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::DIV_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::MOD_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::XOR_ASSIGN_OPERATOR_CODE:
                                 {
                                // printf ("Found an OVERLOADED BINARY OPERATOR expression \n");

                                   SgExpression* expression = isSgExpression(astNode);
                                   ROSE_ASSERT (expression != NULL);

                                   returnString =
                                        synthesizedAttributeList[0].getTransformationSourceCode() +
                                        "$OPERATOR" +
                                        synthesizedAttributeList[1].getTransformationSourceCode();
                                   break;
                                 }

                           // unary operators:
	                      case ArrayTransformationSupport::NOT_OPERATOR_CODE:
	                      case ArrayTransformationSupport::DEREFERENCE_OPERATOR_CODE:
	                      case ArrayTransformationSupport::ADDRESS_OPERATOR_CODE:
                              case ArrayTransformationSupport::LSHIFT_OPERATOR_CODE:
                              case ArrayTransformationSupport::RSHIFT_OPERATOR_CODE:
                              case ArrayTransformationSupport::LSHIFT_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::RSHIFT_ASSIGN_OPERATOR_CODE:
                              case ArrayTransformationSupport::PREFIX_PLUSPLUS_OPERATOR_CODE:
                              case ArrayTransformationSupport::POSTFIX_PLUSPLUS_OPERATOR_CODE:
                              case ArrayTransformationSupport::PREFIX_MINUSMINUS_OPERATOR_CODE:
                              case ArrayTransformationSupport::POSTFIX_MINUSMINUS_OPERATOR_CODE:
                                 {
                                // Assemble the string for "!A" instead of "A!" which is what is currently generated!
                                // assemble the name of the function name + variable refernece to be the string (instead of default assembly!) 

                                // printf ("Found an OVERLOADED UNARY OPERATOR expression \n");

                                   printf ("ERROR: Still need to associated operator with unary expression \n");
                                   ROSE_ABORT();

                                   returnString = synthesizedAttributeList[0].getTransformationSourceCode();
                                   break;
                                 }

                              default:
                                   printf ("default in switch found in variant = %d (arglist parent function name not implemented) \n",operatorCodeVariant);
                                   ROSE_ABORT();
                            }

                         break;
                       }

                    case CONSTRUCTOR_INIT:
                       {
                      // This case is important for the identification of scalars used within
                      // indexing operators (not the same thing as scalar indexing)

                         ROSE_ASSERT (synthesizedAttributeList.size() > 0);
                         string integerExpressionString = synthesizedAttributeList[0].getTransformationSourceCode();

                      // retrieve the variable name from the data base (so that we can add the associated index object names)
                         ROSE_ASSERT (operandDataBase.arrayOperandList.size() > 0);
                         int indexOfLastOperand = operandDataBase.size() - 1;
                         string arrayVariableName = operandDataBase.arrayOperandList[indexOfLastOperand].arrayVariableName;

                      // Record the name of the Index object used
                         operandDataBase.addIntegerExpressionIndexInformation(arrayVariableName,integerExpressionString);

                      // This handles the case of "A(I,2)" where the "2" is promoted to a
                      // InternalIndex though a call to the InternalIndex constructor which takes a
                      // single integer.
                         returnString = integerExpressionString;
                         break;
                       }

                    default:
                       {
                      // Not really sure how to handle it since it depends upon what the parent is!

                         printf ("Parent of SgExprListExp is not a SgFunctionCallExp (need to allow for these cases explicitly) \n");
                         ROSE_ABORT();
                       }
                  }

               returnSynthesizedAttribute.setTransformationSourceCode(returnString);
               break;
             }

          case FUNC_CALL: // tag for SgFunctionCallExp class
             {
            // Error checking: Verify that we have a SgFunctionCallExp object
               SgFunctionCallExp* functionCallExpression = isSgFunctionCallExp(astNode);
               ROSE_ASSERT (functionCallExpression != NULL);

               string operatorName = ArrayTransformationSupport::getFunctionName ( functionCallExpression );
               ROSE_ASSERT (operatorName.c_str() != NULL);

               SgType* functionType = functionCallExpression->get_type();
               string functionTypeName = ArrayTransformationSupport::getTypeName (functionType);

               if ( (functionTypeName != "doubleArray") && 
                    (functionTypeName != "floatArray")  &&
                    (functionTypeName != "intArray") )
                  {
                 // Use this query to handle only A++ function call expressions
                    returnSynthesizedAttribute.setTransformationSourceCode("");
                    break;
                  }

               ROSE_ASSERT ( (functionTypeName == "doubleArray") || 
                             (functionTypeName == "floatArray")  ||
                             (functionTypeName == "intArray") );

            // Get the number of parameters to this function
               SgExprListExp* exprListExp = functionCallExpression->get_args();
               ROSE_ASSERT (exprListExp != NULL);

               SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
               int numberOfParameters = expressionPtrList.size();

               ArrayTransformationSupport::operatorCodeType operatorCodeVariant =
                    ArrayTransformationSupport::classifyOverloadedOperator (operatorName.c_str(),numberOfParameters);

               ROSE_ASSERT (operatorName.length() > 0);

            // Separating this case into additional cases makes up to some 
            // extent for using a more specific higher level grammar.
               switch (operatorCodeVariant)
                  {
                 // normal function call (not an overloaded function) (used as the default value)
                    case ArrayTransformationSupport::FUNCTION_CALL_OPERATOR_CODE:
                         returnString = synthesizedAttributeList[0].getTransformationSourceCode();
                         int n;
                         for (n = 1; n < synthesizedAttributeList.size(); n++)
                            {
                           // concatenate the synthesized attributes
                              returnString = returnString + string(",") +
                                             synthesizedAttributeList[n].getTransformationSourceCode();
                            }
                         returnString = operatorName + string("(") + returnString + string(")");
                         break;

                    case ArrayTransformationSupport::ASSIGN_OPERATOR_CODE:
                       {
                      // The overloaded assignment operator has only the rhs in the argument list
                      // (the lhs is index using the value SgFunctionCallExp_function in the
                      // synthesizedAttributeList)

                         operatorString = ArrayTransformationSupport::buildOperatorString (astNode);

                         string lhsString = synthesizedAttributeList[SgFunctionCallExp_function].getTransformationSourceCode();
                         string rhsString = synthesizedAttributeList[SgFunctionCallExp_args].getTransformationSourceCode();

                      // string lhsOperandName = operandDataBase.arrayOperandList[0].arrayVariableName;
                         vector<ArrayOperandDataBase>::iterator lhs = operandDataBase.arrayOperandList.begin();
                         vector<ArrayOperandDataBase>::iterator rhs = lhs;
                         rhs++;
                         while ( rhs != operandDataBase.arrayOperandList.end() )
                            {
                           // look at the operands on the rhs for a match with the one on the lhs
                              if ( (*lhs).arrayVariableName == (*rhs).arrayVariableName )
                                 {
                                // A loop dependence has been identified
                                // Mark the synthesized attribute to record 
                                // the loop dependence within this statement
                                   returnSynthesizedAttribute.setLoopDependence(TRUE);
                                   returnSynthesizedAttribute.setLoopDependenceLhs(lhsString);
                                   returnSynthesizedAttribute.setLoopDependenceRhs(rhsString);
                                 }

                              rhs++;
                            }

                      // Assemble the final return string
                         returnString = lhsString + rhsString;

                      // Edit the correct operator into place
                         returnString = SgNode::copyEdit(returnString,"$OPERATOR",operatorString);
                         break;
                       }

                 // Overloaded binary operators: These are implemented a friend functions taking 2
                 // parameters instead of member functions taking only 1 parameter, as a result they
                 // have to be handled differently.
                    case ArrayTransformationSupport::ADD_OPERATOR_CODE:
                    case ArrayTransformationSupport::SUBT_OPERATOR_CODE:
                    case ArrayTransformationSupport::MULT_OPERATOR_CODE:
                    case ArrayTransformationSupport::DIV_OPERATOR_CODE:
                    case ArrayTransformationSupport::INTEGER_DIV_OPERATOR_CODE:
                    case ArrayTransformationSupport::MOD_OPERATOR_CODE:
                    case ArrayTransformationSupport::AND_OPERATOR_CODE:
                    case ArrayTransformationSupport::OR_OPERATOR_CODE:
                    case ArrayTransformationSupport::BITXOR_OPERATOR_CODE:
                    case ArrayTransformationSupport::BITAND_OPERATOR_CODE:
                    case ArrayTransformationSupport::BITOR_OPERATOR_CODE:
                    case ArrayTransformationSupport::EQ_OPERATOR_CODE:
                    case ArrayTransformationSupport::LT_OPERATOR_CODE:
                    case ArrayTransformationSupport::GT_OPERATOR_CODE:
                    case ArrayTransformationSupport::NE_OPERATOR_CODE:
                    case ArrayTransformationSupport::LE_OPERATOR_CODE:
                    case ArrayTransformationSupport::GE_OPERATOR_CODE:
                    case ArrayTransformationSupport::PLUS_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::MINUS_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::AND_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::IOR_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::MULT_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::DIV_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::MOD_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::XOR_ASSIGN_OPERATOR_CODE:
                       {
                      // Binary overloaded operators have all their arguments in the argument list

                         SgExpression* expression = isSgExpression(astNode);
                         ROSE_ASSERT (expression != NULL);

                         int parent_precedence =
                              (expression->get_parent()) ? expression->get_parent()->precedence() : 0;
                         int our_precedence    = expression->precedence();
                         int skip_parens       = ((parent_precedence > 0) && (our_precedence > parent_precedence));

                         operatorString = ArrayTransformationSupport::buildOperatorString (astNode);

                         string expressionString =
                              synthesizedAttributeList[SgFunctionCallExp_args].getTransformationSourceCode();
                         returnString = SgNode::copyEdit(expressionString,"$OPERATOR",operatorString);
			 if (!skip_parens)
                            {
			      returnString = "(" + returnString + ")";
                            }

                         break;
                       }

                 // unary operators:
	            case ArrayTransformationSupport::NOT_OPERATOR_CODE:
	            case ArrayTransformationSupport::DEREFERENCE_OPERATOR_CODE:
	            case ArrayTransformationSupport::ADDRESS_OPERATOR_CODE:
	            case ArrayTransformationSupport::LSHIFT_OPERATOR_CODE:
	            case ArrayTransformationSupport::RSHIFT_OPERATOR_CODE:
                    case ArrayTransformationSupport::LSHIFT_ASSIGN_OPERATOR_CODE:
                    case ArrayTransformationSupport::RSHIFT_ASSIGN_OPERATOR_CODE:
	            case ArrayTransformationSupport::PREFIX_PLUSPLUS_OPERATOR_CODE:
	            case ArrayTransformationSupport::POSTFIX_PLUSPLUS_OPERATOR_CODE:
	            case ArrayTransformationSupport::PREFIX_MINUSMINUS_OPERATOR_CODE:
	            case ArrayTransformationSupport::POSTFIX_MINUSMINUS_OPERATOR_CODE:
                       {
                      // Assemble the string for "!A" instead of "A!" which is what is currently generated!
                      // assemble the name of the function name + variable refernece to be the string (instead of default assembly!) 

                      // printf ("Found an OVERLOADED UNARY OPERATOR expression \n");

                         string functionString = 
                              synthesizedAttributeList[SgFunctionCallExp_function].getTransformationSourceCode();
                         string expressionString = 
                              synthesizedAttributeList[SgFunctionCallExp_args].getTransformationSourceCode();
                         returnString = functionString + expressionString;

                         printf ("Exiting after handling general overloaded unary operator: returnString = %s \n",returnString.c_str());
                         ROSE_ABORT();

                         break;
                       }

                    case ArrayTransformationSupport::PARENTHESIS_OPERATOR_CODE:
                       {
                         ROSE_ASSERT (operatorName == "operator()");

                      // Now get the operands out and search for the offsets in the index objects

                      // Get the value of the offsets (start the search from the functionCallExp)
                         SgExprListExp* exprListExp = functionCallExpression->get_args();
                         ROSE_ASSERT (exprListExp != NULL);

                         SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
                         SgExpressionPtrList::iterator i = expressionPtrList.begin();

                      // We only want to pass on the transformationOptions as inherited attributes
                      // to the indexOffsetQuery
                         list<int> & transformationOptionList =
                              arrayAssignmentStatementQueryInheritedData.getTransformationOptions();

                         string indexOffsetString[6];

                      // retrieve the variable name from the data base (so that we can add the associated index object names)
                         int lastOperandInDataBase = operandDataBase.size()-1;
                         ArrayOperandDataBase & arrayOperandDB =
                              operandDataBase.arrayOperandList[lastOperandInDataBase];
                         string arrayVariableName = arrayOperandDB.arrayVariableName;

                         string arrayDataPointerNameSubstring = string("_") + arrayVariableName;

                         if (expressionPtrList.size() == 0)
                            {
                           // Case of A() (index object with no offset integer expression) Nothing to do here (I think???)
                              printf ("Special case of Indexing with no offset! exiting ... \n");
                              ROSE_ABORT();

                              returnString = "";
                           // returnSynthesizedAttribute.setTransformationSourceCode("");
                            }
                           else
                            {
                           // Case of indexing objects used within operator()
                              int counter = 0;
	                      while (i != expressionPtrList.end()) 
                                 {
                                // Build up the name of the final index variable (or at least give
                                // it a unique number by dimension)
                                   string counterString  = StringUtility::numberToString(counter+1);

                                // Call another transformation mechanism to generate string for the index
                                // expression (since we don't have an unparser mechanism in ROSE yet)
                                   indexOffsetString [counter] = IndexOffsetQuery::transformation ( *i );

                                   ROSE_ASSERT (indexOffsetString[counter].c_str() != NULL);

                                // Accumulate a list of all the InternalIndex, Index, and Range objects
                                   list<string> indexNameList =
                                        NameQuery::getVariableNamesWithTypeNameQuery ( *i, "Index" );
                                   list<string> rangeNameList =
                                        NameQuery::getVariableNamesWithTypeNameQuery ( *i, "Range" );
                                   list<string> internalIndexNameList =
                                        NameQuery::getVariableNamesWithTypeNameQuery ( *i, "InternalIndex" );

                                // We have to sort the lists before we can call the merge function
                                   indexNameList.sort();
                                   rangeNameList.sort();
                                   internalIndexNameList.sort();

                                // Now merge the lists
                                   indexNameList.merge(rangeNameList);
                                   indexNameList.merge(internalIndexNameList);

                                // Make sure that we only have one InternalIndex object used in the index expression
                                   if (indexNameList.size() == 0)
                                      {
                                     // case of scalar indexing
                                     // The final transformations will use index variables of the form
                                     // "_1" through "_6"
                                        string indexVariableString = indexOffsetString[counter];

                                        indexOffsetString[counter] =
                                             SgNode::copyEdit(indexOffsetString[counter],"$INDEX_OBJECT",indexVariableString);

                                     // Record the name of the Index object used
                                        operandDataBase.addIndexInformation(arrayVariableName,"SCALAR");
                                      }
                                     else
                                      {
                                        ROSE_ASSERT (indexNameList.size() == 1);
                                        string indexVariableName = *(indexNameList.begin());

                                     // Accumulate a string from concatination of the index variable names
                                     // (to be use to build a unique identifier for the data pointer)
                                        arrayDataPointerNameSubstring += string("_") + indexVariableName;

                                     // The final transformations will use index variables of the form
                                     // "_1" through "_6"
                                        string indexVariableString = string("_") + counterString;

                                        indexOffsetString[counter] =
                                             SgNode::copyEdit(indexOffsetString[counter],"$INDEX_OBJECT",indexVariableString);

                                     // Record the name of the Index object used
                                        operandDataBase.addIndexInformation(arrayVariableName,indexVariableName);
                                      }

                                   i++;
                                   counter++;
                                 }

                           // Need to fix subscript computation if counter > 1 (so make this case an error)
                              ROSE_ASSERT (counter >= 0);
                              ROSE_ASSERT (counter <= maxNumberOfIndexOffsets);

                           // The inherited attribute needs to be modified with the computed array
                           // dimension and then used in subsequent queries.  But we can't modify the
                           // inherited attribute by desing so we have to use an other inherited
                           // attribute as with the correct array dimension.  This is not implemented yet
                           // in the array assignement statement transformation.

                           // This is the more strict requirement that has to be asserted in A++/P++
                              ROSE_ASSERT (counter == maxNumberOfIndexOffsets);

                           // reset the offsetString to use the new list of index expressions
                              int n = 0;
                              offsetString = "";
                              for (n = 0; n < maxNumberOfIndexOffsets; n++)
                                 {
                                // Add the different expressions represented by the indexing strings together
                                   if ( n > 0 )
                                        offsetString += ",";

                                   ROSE_ASSERT (indexOffsetString[n].c_str() != NULL);
                                   offsetString += indexOffsetString[n];
                                 }
                            }

                      // Declare the string which will be modified
                         string arrayReferenceString =
                              synthesizedAttributeList[SgFunctionCallExp_function].getTransformationSourceCode();
                      // Modify the $OFFSET in for example:
                      // $IDENTIFIER_STRING_pointer[SC$IDENTIFIER_STRING($OFFSET)]
                         returnString = SgNode::copyEdit(arrayReferenceString,"$OFFSET",offsetString);

                      // Modify the $IDENTIFIER_STRING in for example:
                      // $IDENTIFIER_STRING_pointer[SC_$IDENTIFIER_STRING($OFFSET)]
                         returnString = SgNode::copyEdit(returnString,"$IDENTIFIER_STRING",arrayDataPointerNameSubstring);

                      // Optimize the case of uniform or unit indexing to generate a single subscript macro definition
                         if ( (arrayOperandDB.indexingAccessCode == ArrayTransformationSupport::UniformSizeUnitStride) ||
                              (arrayOperandDB.indexingAccessCode == ArrayTransformationSupport::UniformSizeUniformStride) )
                              returnString = SgNode::copyEdit (returnString,"$MACRO_NAME_SUBSTRING","");
                           else
                              returnString = SgNode::copyEdit (returnString,"$MACRO_NAME_SUBSTRING",arrayDataPointerNameSubstring);

                         break;
                       }

                    default:
                         printf ("default in switch found in variant = %d (NAME NOT IMPLEMENTED) \n",operatorCodeVariant);
                         ROSE_ABORT();
                  }

               returnSynthesizedAttribute.setTransformationSourceCode(returnString);
               break;

               returnSynthesizedAttribute.setTransformationSourceCode(returnString);
               break;
             }

       // These cases have been moved from the local function
       // Values
          case ValueExpTag:
          case BOOL_VAL:
          case STRING_VAL:
          case SHORT_VAL:
          case CHAR_VAL:
          case UNSIGNED_CHAR_VAL:
          case WCHAR_VAL:
          case UNSIGNED_SHORT_VAL:
          case ENUM_VAL:
          case UNSIGNED_INT_VAL:
          case LONG_INT_VAL:
          case LONG_LONG_INT_VAL:
          case UNSIGNED_LONG_LONG_INT_VAL:
          case UNSIGNED_LONG_INT_VAL:
          case INT_VAL:
          case FLOAT_VAL:
          case DOUBLE_VAL:
          case LONG_DOUBLE_VAL:
             {
            // Call the unparser to generate a string for any value (shortest possible way to generate string)
               string returnString = astNode->unparseToString();
               returnSynthesizedAttribute.setTransformationSourceCode(returnString);
               break;
             }

       // Added VAR_REF case (moved from the local function)
          case VAR_REF:
             {
            // A VAR_REF has to output a string (the variable name)

            // Since we are at a leaf in the traversal of the AST this attribute list should a size of 0.
               ROSE_ASSERT (synthesizedAttributeList.size() == 0);

               SgVarRefExp* varRefExp = isSgVarRefExp(astNode);
               ROSE_ASSERT (varRefExp != NULL);
               SgVariableSymbol* variableSymbol = varRefExp->get_symbol();
               ROSE_ASSERT (variableSymbol != NULL);
               SgInitializedName* initializedName = variableSymbol->get_declaration();
               ROSE_ASSERT (initializedName != NULL);
               SgName variableName = initializedName->get_name();

               string buffer;
               string indexOffsetString;

               SgType* type = variableSymbol->get_type();
               ROSE_ASSERT (type != NULL);

               string typeName = ArrayTransformationSupport::getTypeName(type);
               ROSE_ASSERT (typeName.c_str() != NULL);

            // return value for this case
               string returnString;

            // Recognize only these types at present
               if ( typeName == "intArray" || typeName == "floatArray" || typeName == "doubleArray" )
                  {
                 // Only define the variable name if we are using an object of array type

                 // Use a macro to make this easier to read
                    string subscriptString;

                 // Handle the selection of subscript macro at a higher level of the AST
                 // subscriptString = "$INDEXING_SUBSCRIPT_COMPUTATION";

                 // Copy the string from the SgName object to a string object
                    string variableNameString = variableName.str();

                 // Setup an intry in the synthesized attribute data base for this variable any
                 // future results from analysis could be place there at this point as well
                 // record the name in the synthesized attribute
                 // returnSynthesizedAttribute.setVariableName(variableNameString);
                    ROSE_ASSERT ( operandDataBase.transformationOption > ArrayTransformationSupport::UnknownIndexingAccess );
                    ArrayOperandDataBase arrayOperandDB = operandDataBase.setVariableName(variableNameString);

                 // We could have specified in the inherited attribute that this array variable was
                 // index and if so leave the value of $IDENTIFIER_STRING to be modified later in
                 // the assembly of the operator() and if not do the string replacement on
                 // $IDENTIFIER_STRING here (right now).

                    returnString = string("$IDENTIFIER_STRING") + string("_pointer[SC") + 
                                   string("$MACRO_NAME_SUBSTRING") + string("(") + 
                                   string("$OFFSET") + string(")]");

                 // The inherited attribute mechanism is not yet implimented
                    if (arrayAssignmentStatementQueryInheritedData.getIsIndexedArrayOperand() == FALSE)
                       {
                      // do the substitution of $OFFSET here since it our last chance
                      // (offsetString is the list of index values "index1,index2,...,indexn")
                         returnString = SgNode::copyEdit(returnString,"$OFFSET",offsetString);

                         string operandIdentifier = arrayOperandDB.generateIdentifierString();
                      // do the substitution of $IDENTIFIER_STRING here since it our last chance
                      // if variable name is "A", generate: A_pointer[SC_A(index1,...)]
                      // returnString = SgNode::copyEdit (returnString,"$IDENTIFIER_STRING",variableNameString);
                         ROSE_ASSERT ( arrayOperandDB.indexingAccessCode > 
                                       ArrayTransformationSupport::UnknownIndexingAccess);

                      // Edit into place the name of the data pointer
                         returnString = SgNode::copyEdit (returnString,"$IDENTIFIER_STRING",operandIdentifier);

                      // Optimize the case of uniform or unit indexing to generate a single subscript macro definition
                         if ( (arrayOperandDB.indexingAccessCode == ArrayTransformationSupport::UniformSizeUnitStride) ||
                              (arrayOperandDB.indexingAccessCode == ArrayTransformationSupport::UniformSizeUniformStride) )
                              returnString = SgNode::copyEdit (returnString,"$MACRO_NAME_SUBSTRING","");
                           else
                              returnString = SgNode::copyEdit (returnString,"$MACRO_NAME_SUBSTRING",operandIdentifier);
                       }
                  }
                 else
                  {
                 // variable is of some other type wo just output the variable name as an unparser would
                    returnString = variableName.str();
                  }

               returnSynthesizedAttribute.setTransformationSourceCode(returnString);

               break;
             }

       // Removed VAR_REF case from below
          case RECORD_REF:  // SgDotExp
       // case ValueExpTag:
          default:
             {
            // The default is to concatinate all the strings together (in the order in which they appear)

               for (i = synthesizedAttributeList.begin(); i != synthesizedAttributeList.end(); i++)
                  {
                 // Call the ArrayAssignmentStatementQuerySynthesizedAttributeType::operator+= overloaded operator
                    returnSynthesizedAttribute += *i;
                  }
               break;
             }
        }

     return returnSynthesizedAttribute;
   }

\end{lstlisting}
}


% \newpage$
\section{Location of \axx Preprocessor on CASC Network}
    The current distribution of the \axx preprocessor is at: \\
    {\tt /usr/case/overture/ROSE/March-26-2002/A++P++Preprocessor/axx} \\

  Running {\tt make check} in this directory
will automatically test the preprocessor on a collection of test codes.  In each case the test code
is read in, a new test code with prefix {\tt rose\_} is written out, and the output testcode from the
preprocessor is compiled with the options specified on the command line.  Thus \axx acts just like the
a compiler and can replace the use of your compiler within any project.  It is assumed that any project
has Makefiles sufficiently flexible to permit changing the name of the compiler.

% \newpage
\section{How to Control Optimizations within \axx}
    By default all transformation generate completely general code (though currently we exclude
indirect addressing and where statement transformations).  The user can control optimizations within
the preprocessor through the declaration of variables of a specific type (TransformationAssertion
objects) and the input of specific options to their constructors.

Options that can be used at parameters to control the preprocessor optimizations include:
\begin{itemize}
   \item SkipTransformation             (not implemented)
   \item NoWhereStatementTransformation (not implemented)
   \item WhereStatementTransformation   (not implemented)
   \item NoIndirectAddressing           (not implemented)
   \item IndirectAddressing             (not implemented)
   \item ConstantStrideAccess
   \item StrideOneAccess
   \item VariableStrideAccess
   \item SameSizeArrays
   \item DifferentSizeArrays
   \item SameParallelDistributions      (not implemented)
   \item DifferentParallelDistributions (not implemented)
\end{itemize}

   Since the mechanism uses variable declarations as a way to control the optimization, the syntax is:
   $$ TransformationAssertion <unique variable name> (<option>); $$

   The following example shows addition of declarations to the global, local scopes to control of
optimizations by the preprocessor:

\vspace{0.5in}

\begin{lstlisting}{}

#include ``A++.h''

// Mechanism to specify options to the preprocessor (global scope)
// Currently we don't handle where statements or indirect addressing (so assert that there are none)
TransformationAssertion globalScope0 (TransformationAssertion::NoWhereStatementTransformation,
                                      TransformationAssertion::NoIndirectAddressing);

int main()
   {
  // First optimization permits all the size# variables to be the same across all operands (this
  // should significantly reduce the registar pressure).
     TransformationAssertion assertion1 (TransformationAssertion::SameSizeArrays);

  // Specification of uniform stride permits all the <name>_stride# variables to be the same across
  // all operands (further reducing the register pressure).
     TransformationAssertion assertion2 (TransformationAssertion::ConstantStrideAccess);

     bool booleanValue = TRUE;
     doubleArray A(10);
     doubleArray B(10);

     A = 0;
     B = 0;

     if (booleanValue)
        {
       // In addition to uniform stride we specify here that the stride is lenght 1 which permits
       // additional optimizations to the subscript computation (or the loop nest) to remove the stride
       // variable from the computations altogether.
          TransformationAssertion assertion3 (TransformationAssertion::StrideOneAccess);

       // stride 1 array statements
          Range I (1,8,1);
          A(I) = ( A(I-1) + A(I+1) ) * 0.5;
        }
       else
        {
       // Turn off the same size array optimizations (generate size variables for each operand)
          TransformationAssertion assertion3 (TransformationAssertion::DifferentSizeArrays);

       // Turn off the unit and uniform stride optimizations (generate stride variables for each operand)
          TransformationAssertion assertion4 (TransformationAssertion::VariableStrideAccess);

       // stride 2 array statements
          Range I (1,8,2);
          Range J (1,8,1);
          A(J) = ( B(I-1) + B(I+1) ) * 0.5;
        }

     return 0;
   }

\end{lstlisting}

% \newpage
\section{Examples}
    This section presents numerous examples of transformations that are automated using \axx.

\subsection{Simple Assignment Statement}

\subsubsection{Default transformation without specification of semantic assertions}

    If the mechanism for specifying the semantics in the users application is {\bf NOT} used then we
can't currently know that the array operands have the same size, stride, or know anything specific
about the values associated with the strides (e.g. strinde 1 access).  In this case the
transformations are generated with a degree of generality that allows them to be executed
independent their context within the application.  The trade-off is that the transformation will
have additional overhead which might otherwise be optimized away.


   The following trivial example shows an array statement.  In this case a single expression is represented
(the doubleArray::operator=()).

   For the array statement:
\vspace{0.5in}

\begin{lstlisting}{}

doubleArray A(10);
A = 0;

\end{lstlisting}

% \newpage

   we generate the following transformation:

\vspace{0.5in}

\begin{lstlisting}{}

int functionA()
   { 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D6(_A); 
     double * _A_pointer = ((double * )0); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D6(_A); 
     int _1; 
     int _2; 
     int _3; 
     int _4; 
     int _5; 
     int _6; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
     int _length4 = 0; 
     int _length5 = 0; 
     int _length6 = 0;
     class doubleArray A(10);
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D6(A,_A); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D6(A,_A); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D6(A); 
     _A_pointer = (A.getAdjustedDataPointer)(); 
     #define SC_A(x1,x2,x3,x4,x5,x6) /* case VariableSizeVariableStride */ \
          (x1)*_A_stride1+((x2)*_A_stride2*_A_size1)+((x3)*_A_stride3*_A_size2)+\
         ((x4)*_A_stride4*_A_size3)+((x5)*_A_stride5*_A_size4)+((x6)*_A_stride6*_A_size5)
; 
     for (_6 = 0; _6 < _length6; _6++)
        { 
          for (_5 = 0; _5 < _length5; _5++)
          { 
            for (_4 = 0; _4 < _length4; _4++)
            { 
              for (_3 = 0; _3 < _length3; _3++)
              { 
                for (_2 = 0; _2 < _length2; _2++)
                { 
                  for (_1 = 0; _1 < _length1; _1++)
                  { 
                    _A_pointer[SC_A(_1,_2,_3,_4,_5,_6)] = 0.0; 
                  } 
                } 
              } 
            } 
          } 
        } 

     return 0;
} 

\end{lstlisting}

Within this case, because we didn't know the dimensionality of the array object {\tt A}, we were
forced to assume it could have the maximal dimensionality representable in the A++/P++ array class
library.  The semantics of array objects is that they can be up to six dimensional.  So the
transformation requires a six level loop next to be generated.  Notice also that subscript
computation represented by the macro {\tt SC\_A(x1,x2,x3,x4,x5,x6)} is six dimensional and contains
variables representing the stride (e.g. {\tt \_A\_stride6}) and the size (e.g. {\tt \_A\_size5}).

If we were to know at compile time that the stride have the value 1, then the stride variables could
have been eliminated from the substript computation.  The resulting code would have fewer variables
associated with its subscript computation and, in the case of statements involving several operands,
would be more efficient.

\subsubsection{Specification of Transformation Assertions (assert stride == 1)}

   The following code shows the transformation for the case of where the user has specified directly in his
code that the stride has the value one (stride == 1).

\vspace{0.5in}

\begin{lstlisting}{}

int functionE()
   { 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D6(_A); 
     double * _A_pointer = ((double * )0); 
     int _1; 
     int _2; 
     int _3; 
     int _4; 
     int _5; 
     int _6; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
     int _length4 = 0; 
     int _length5 = 0; 
     int _length6 = 0; 

  // Specify unit stride to generate better optimized execution (removes stride from computation)
     class TransformationAssertion assertion3(TransformationAssertion::StrideOneAccess); 

     class doubleArray A(10);
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D6(A,_A); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D6(A); 
     _A_pointer = (A.getAdjustedDataPointer)(); 
     #define SC_A(x1,x2,x3,x4,x5,x6) /* case VariableSizeUnitStride */ \
          (x1)+((x2)*_A_size1)+((x3)*_A_size2)+((x4)*_A_size3)+((x5)*_A_size4)+((x6)*_A_size5)
; 
     for (_6 = 0; _6 < _length6; _6++)
        { 
          for (_5 = 0; _5 < _length5; _5++)
          { 
            for (_4 = 0; _4 < _length4; _4++)
            { 
              for (_3 = 0; _3 < _length3; _3++)
              { 
                for (_2 = 0; _2 < _length2; _2++)
                { 
                  for (_1 = 0; _1 < _length1; _1++)
                  { 
                    _A_pointer[SC_A(_1,_2,_3,_4,_5,_6)] = 0.0; 
                  } 
                } 
              } 
            } 
          } 
        } 

     return 0;
   } 

\end{lstlisting}

% \newpage
\subsection{More interesting array statements: Residual Computation}

   The following array statement has more operands, includes indexing, and shows a generally
more complex array statement and the transformations that are generated with different explicit
transformation assertions added to the user's original source code.

% \subsubsection{Single Statements with no Loop Dependence}

   Stencils are interesting because they occure often in scientific computing.

\subsubsection{Initial array statement before transformation}

   This shows the A++\/P++ array statement before transformation:

\vspace{0.5in}

\begin{lstlisting}{}
     int n; \
     Range I,J,K; \
     doubleArray Residual(n,n,n); \
     doubleArray Right_Hand_Side(n,n,n); \
     doubleArray Solution(n,n,n); \
     double Scaling_Factor; \
     Residual (I,J,K) = Right_Hand_Side (I,J,K) + Scaling_Factor * ( \
                        Solution (I+1,J,K) + Solution (I-1,J,K) + \
                        Solution (I,J-1,K) + Solution (I,J+1,K) + Solution (I,J,K-1) + \
                        Solution (I,J,K+1) - 6.0 * Solution (I,J,K) );
\end{lstlisting}

% \newpage

\subsubsection{Default transformation with no transformation assertions}

The following transformation assumes no user specified transformation assertions (see previous sections):

\begin{lstlisting}{}
int functionA()
   { 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D3(_Residual); 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D3(_Right_Hand_Side); 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D3(_Solution); 
     double * _Residual_I_J_K_pointer = ((double * )0); 
     double * _Right_Hand_Side_I_J_K_pointer = ((double * )0); 
     double * _Solution_I_J_K_pointer = ((double * )0); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D3(_Residual_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D3(_Right_Hand_Side_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D3(_Solution_I_J_K); 
     int _1; 
     int _2; 
     int _3; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0;
     int n;
     class Range I; 
     class Range J;
     class Range K;
     class doubleArray Residual(n,n,n);
     class doubleArray Right_Hand_Side(n,n,n);
     class doubleArray Solution(n,n,n);
     double Scaling_Factor; 
     #define SC_Residual_I_J_K(x1,x2,x3) /* case VariableSizeVariableStride */ \
          (x1)*_Residual_I_J_K_stride1+((x2)*_Residual_I_J_K_stride2*_Residual_size1)+\
         ((x3)*_Residual_I_J_K_stride3*_Residual_size2)
;
     #define SC_Right_Hand_Side_I_J_K(x1,x2,x3) /* case VariableSizeVariableStride */ \
          (x1)*_Right_Hand_Side_I_J_K_stride1+((x2)*_Right_Hand_Side_I_J_K_stride2*_Right_Hand_Side_size1)+\
         ((x3)*_Right_Hand_Side_I_J_K_stride3*_Right_Hand_Side_size2)
;
     #define SC_Solution_I_J_K(x1,x2,x3) /* case VariableSizeVariableStride */ \
          (x1)*_Solution_I_J_K_stride1+((x2)*_Solution_I_J_K_stride2*_Solution_size1)+
         ((x3)*_Solution_I_J_K_stride3*_Solution_size2)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D3(Residual,_Residual); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D3(Right_Hand_Side,_Right_Hand_Side); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D3(Solution,_Solution); 
     _Residual_I_J_K_pointer = (Residual.getAdjustedDataPointer)(I,J,K); 
     _Right_Hand_Side_I_J_K_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J,K); 
     _Solution_I_J_K_pointer = (Solution.getAdjustedDataPointer)(I,J,K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D3(Residual,_Residual_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D3(Right_Hand_Side,_Right_Hand_Side_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D3(Solution,_Solution_I_J_K); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D3(Residual); 
     for (_3 = 0; _3 < _length3; _3++)
        { 
          for (_2 = 0; _2 < _length2; _2++)
          { 
            for (_1 = 0; _1 < _length1; _1++)
            { 
              _Residual_I_J_K_pointer[SC_Residual_I_J_K(_1,_2,_3)] =
                   _Right_Hand_Side_I_J_K_pointer[SC_Right_Hand_Side_I_J_K(_1,_2,_3)] + 
                   Scaling_Factor * ((((((_Solution_I_J_K_pointer[SC_Solution_I_J_K((_1 + 1),_2,_3)] + 
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K((_1 - 1),_2,_3)]) +
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,(_2 - 1),_3)]) +
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,(_2 + 1),_3)]) + 
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,_2,(_3 - 1))]) +
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,_2,(_3 + 1))]) -
                                          6.0 * _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,_2,_3)]); 
            } 
          } 
        } 

     return 0;
} 
\end{lstlisting}

% \newpage

\subsubsection{Transformation with transformation assertions (SameSizeArrays)}

   The following example shows the same transformation but with the specification of a
transformation assertion that the arrays all have the same size.

\begin{lstlisting}{}
int functionB()
   { 
     ARRAY_OPERAND_UNIFORM_SIZE_DECLARATION_MACRO_D3(); 
     double * _Residual_I_J_K_pointer = ((double * )0); 
     double * _Right_Hand_Side_I_J_K_pointer = ((double * )0); 
     double * _Solution_I_J_K_pointer = ((double * )0); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D3(_Residual_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D3(_Right_Hand_Side_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D3(_Solution_I_J_K); 
     int _1; 
     int _2; 
     int _3; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
  // First optimization permits all the size# variables to be the same across all operands (this
  // should significantly reduce the registar pressure).
     class TransformationAssertion assertion1(TransformationAssertion::SameSizeArrays); 

     int n;
     class Range I;
     class Range J;
     class Range K;
     class doubleArray Residual(n,n,n);
     class doubleArray Right_Hand_Side(n,n,n);
     class doubleArray Solution(n,n,n);
     double Scaling_Factor; 
     #define SC_Residual_I_J_K(x1,x2,x3) /* case UniformSizeVariableStride */ \
          (x1)*_Residual_I_J_K_stride1+((x2)*_Residual_I_J_K_stride2*_size1)+((x3)*_Residual_I_J_K_stride3*_size2)
;
     #define SC_Right_Hand_Side_I_J_K(x1,x2,x3) /* case UniformSizeVariableStride */ \
          (x1)*_Right_Hand_Side_I_J_K_stride1+((x2)*_Right_Hand_Side_I_J_K_stride2*_size1)+((x3)*_Right_Hand_Side_I_J_K_stride3*_size2)
;
     #define SC_Solution_I_J_K(x1,x2,x3) /* case UniformSizeVariableStride */ \
          (x1)*_Solution_I_J_K_stride1+((x2)*_Solution_I_J_K_stride2*_size1)+((x3)*_Solution_I_J_K_stride3*_size2)
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D3(Residual); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D3(Right_Hand_Side,_Right_Hand_Side_I_J_K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D3(Solution,_Solution_I_J_K); 
     _Residual_I_J_K_pointer = (Residual.getAdjustedDataPointer)(I,J,K); 
     _Right_Hand_Side_I_J_K_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J,K); 
     _Solution_I_J_K_pointer = (Solution.getAdjustedDataPointer)(I,J,K); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D3(Residual,_Residual_I_J_K); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D3(Residual); 
     for (_3 = 0; _3 < _length3; _3++)
        { 
          for (_2 = 0; _2 < _length2; _2++)
          { 
            for (_1 = 0; _1 < _length1; _1++)
            { 
              _Residual_I_J_K_pointer[SC_Residual_I_J_K(_1,_2,_3)] =
                   _Right_Hand_Side_I_J_K_pointer[SC_Right_Hand_Side_I_J_K(_1,_2,_3)] + 
                   Scaling_Factor * ((((((_Solution_I_J_K_pointer[SC_Solution_I_J_K((_1 + 1),_2,_3)] + 
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K((_1 - 1),_2,_3)]) +
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,(_2 - 1),_3)]) +
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,(_2 + 1),_3)]) + 
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,_2,(_3 - 1))]) +
                                          _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,_2,(_3 + 1))]) -
                                          6.0 * _Solution_I_J_K_pointer[SC_Solution_I_J_K(_1,_2,_3)]);
            } 
          } 
        } 

     return 0;
} 

\end{lstlisting}

% \newpage

\subsubsection{Transformation with transformation assertions (SameSizeArrays \&\& ConstantStrideAccess)}

  The following transformation is further optimized by adding the transformation assertion that the strides are uniform within
the array expressions within the array statements.

\begin{lstlisting}{}

int functionC()
   { 
     ARRAY_OPERAND_UNIFORM_SIZE_DECLARATION_MACRO_D3(); 
     double * _Residual_I_J_K_pointer = ((double * )0); 
     double * _Right_Hand_Side_I_J_K_pointer = ((double * )0); 
     double * _Solution_I_J_K_pointer = ((double * )0); 
     ARRAY_OPERAND_UNIFORM_STRIDE_DECLARATION_MACRO_D3(); 
     int _1; 
     int _2; 
     int _3; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
     extern int _stride1; 
     extern int _stride2; 
     extern int _stride3; 
     extern int _stride4; 
     extern int _stride5; 
     extern int _stride6; 
  // First optimization permits all the size# variables to be the same across all operands (this
  // should significantly reduce the registar pressure).
     class TransformationAssertion assertion1(TransformationAssertion::SameSizeArrays); 

  // Specification of uniform stride permits all the <name>_stride# variables to be the same across
  // all operands (further reducing the register pressure).
     class TransformationAssertion assertion2(TransformationAssertion::ConstantStrideAccess); 

     int n;
     class Range I;
     class Range J;
     class Range K;
     class doubleArray Residual(n,n,n);
     class doubleArray Right_Hand_Side(n,n,n);
     class doubleArray Solution(n,n,n);
     double Scaling_Factor; 
     #define SC(x1,x2,x3) /* case UniformSizeUniformStride */ (x1)+((x2)*_size1)+((x3)*_size2)
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D3(Residual); 
     _Residual_I_J_K_pointer = (Residual.getAdjustedDataPointer)(I,J,K); 
     _Right_Hand_Side_I_J_K_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J,K); 
     _Solution_I_J_K_pointer = (Solution.getAdjustedDataPointer)(I,J,K); 
     ARRAY_OPERAND_UNIFORM_STRIDE_INITIALIZATION_MACRO_D3(Residual); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D3(Residual); 
     for (_3 = 0; _3 < _length3; _3 += _stride3)
        { 
          for (_2 = 0; _2 < _length2; _2 += _stride2)
          { 
            for (_1 = 0; _1 < _length1; _1 += _stride1)
            { 
              _Residual_I_J_K_pointer[SC(_1,_2,_3)] = _Right_Hand_Side_I_J_K_pointer[SC(_1,
              _2,_3)] + Scaling_Factor * ((((((_Solution_I_J_K_pointer[SC((_1 + 1),_2,
              _3)] + _Solution_I_J_K_pointer[SC((_1 - 1),_2,_3)]) + _Solution_I_J_K_pointer[SC(_1,
              (_2 - 1),_3)]) + _Solution_I_J_K_pointer[SC(_1,(_2 + 1),_3)]) + _Solution_I_J_K_pointer[SC(_1,
              _2,(_3 - 1))]) + _Solution_I_J_K_pointer[SC(_1,_2,(_3 + 1))]) - 6.0
               * _Solution_I_J_K_pointer[SC(_1,_2,_3)]); 
            } 
          } 
        } 

     return 0;
   } 

\end{lstlisting}

% \newpage

\subsubsection{Transformation with transformation assertions (SameSizeArrays \&\& ConstantStrideAccess \&\& stride == 1)}

   The final transformation presented here adds the additional transformation assertion that the
stride value is 1 (stride == 1).

\begin{lstlisting}{}

int functionD()
   { 
     ARRAY_OPERAND_UNIFORM_SIZE_DECLARATION_MACRO_D3(); 
     double * _Residual_I_J_K_pointer = ((double * )0); 
     double * _Right_Hand_Side_I_J_K_pointer = ((double * )0); 
     double * _Solution_I_J_K_pointer = ((double * )0); 
     int _1; 
     int _2; 
     int _3; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
  // First optimization permits all the size# variables to be the same across all operands (this
  // should significantly reduce the registar pressure).
     class TransformationAssertion assertion1(TransformationAssertion::SameSizeArrays); 

  // Specification of uniform stride permits all the <name>_stride# variables to be the same across
  // all operands (further reducing the register pressure).
     class TransformationAssertion assertion2(TransformationAssertion::ConstantStrideAccess); 

  // In addition to uniform stride we specify here that the stride is lenght 1 which permits
  // additional optimizations to the subscript computation (or the loop nest) to remove the stride
  // variable from the computations altogether.
     class TransformationAssertion assertion3(TransformationAssertion::StrideOneAccess); 

     int n;
     class Range I;
     class Range J;
     class Range K;
     class doubleArray Residual(n,n,n);
     class doubleArray Right_Hand_Side(n,n,n);
     class doubleArray Solution(n,n,n);
     double Scaling_Factor; 
     #define SC(x1,x2,x3) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1+(x3)*_size2
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D3(Residual); 
     _Residual_I_J_K_pointer = (Residual.getAdjustedDataPointer)(I,J,K); 
     _Right_Hand_Side_I_J_K_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J,K); 
        _Solution_I_J_K_pointer = (Solution.getAdjustedDataPointer)(I,J,K); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D3(Residual); 
     for (_3 = 0; _3 < _length3; _3++)
        { 
          for (_2 = 0; _2 < _length2; _2++)
          { 
            for (_1 = 0; _1 < _length1; _1++)
            { 
              _Residual_I_J_K_pointer[SC(_1,_2,_3)] = _Right_Hand_Side_I_J_K_pointer[SC(_1,
              _2,_3)] + Scaling_Factor * ((((((_Solution_I_J_K_pointer[SC((_1 + 1),_2,
              _3)] + _Solution_I_J_K_pointer[SC((_1 - 1),_2,_3)]) + _Solution_I_J_K_pointer[SC(_1,
              (_2 - 1),_3)]) + _Solution_I_J_K_pointer[SC(_1,(_2 + 1),_3)]) + _Solution_I_J_K_pointer[SC(_1,
              _2,(_3 - 1))]) + _Solution_I_J_K_pointer[SC(_1,_2,(_3 + 1))]) - 6.0
               * _Solution_I_J_K_pointer[SC(_1,_2,_3)]); 
            } 
          } 
        } 

     return 0;
   } 

\end{lstlisting}


\subsection{ More interesting array statements: Stencil with Loop Dependence }

     The following array statement contains a loop dependence and so must be handled more carefully.
To preserve the array sematics (the rhs is fully evaluated before assignment), which is required to
permit parallel execution of the A++ array statements with P++, we have to implement the
transformation in two phases.
    
\subsubsection{Original array statements before transformation}

\begin{lstlisting}{}
int n;
Range I,J,K;
doubleArray Right_Hand_Side(n,n);
doubleArray Solution(n,n);
double Mesh_Size;
Solution (I,J) = ( (Mesh_Size * Mesh_Size) * Right_Hand_Side (I,J) +
                   Solution (I+1,J) + Solution (I-1,J) + Solution (I,J+1) + Solution (I,J-1) +
                   Solution (I+1,J+1) + Solution (I+1,J-1) + Solution (I-1,J+1) + Solution (I-1,J-1)) / 8.0;
\end{lstlisting}

\subsubsection{Transformation with no transformation assertions}

\begin{lstlisting}{}

int functionA()
   { 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(_Right_Hand_Side); 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(_Solution); 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(__T); 
     double * _Right_Hand_Side_I_J_pointer = ((double * )0); 
     double * _Solution_I_J_pointer = ((double * )0); 
     double * __T_I_J_pointer = ((double * )0); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(_Right_Hand_Side_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(_Solution_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(__T_I_J); 
     int _1; 
     int _2; 
     int _length1 = 0; 
     int _length2 = 0; 
     class doubleArray _T;
     int n;
     class Range I;
     class Range J;
     class Range K;
     class doubleArray Right_Hand_Side(n,n);
     class doubleArray Solution(n,n);
     double Mesh_Size; 
     #define SC_Right_Hand_Side_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_Right_Hand_Side_I_J_stride1+((x2)*_Right_Hand_Side_I_J_stride2*_Right_Hand_Side_size1)
;
     #define SC_Solution_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_Solution_I_J_stride1+((x2)*_Solution_I_J_stride2*_Solution_size1)
;
     #define SC__T_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*__T_I_J_stride1+((x2)*__T_I_J_stride2*__T_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(Right_Hand_Side,_Right_Hand_Side); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(Solution,_Solution); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(_T,__T); 
     _Right_Hand_Side_I_J_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J); 
     _Solution_I_J_pointer = (Solution.getAdjustedDataPointer)(I,J); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(I,J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(Right_Hand_Side,_Right_Hand_Side_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(Solution,_Solution_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(_T,__T_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(Solution); 
     _T.redim(Solution); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC__T_I_J(_1,_2)] = 
               (((((((((Mesh_Size * Mesh_Size) *
               _Right_Hand_Side_I_J_pointer[SC_Right_Hand_Side_I_J(_1,_2)] +
               _Solution_I_J_pointer[SC_Solution_I_J((_1 + 1),_2)]) +
               _Solution_I_J_pointer[SC_Solution_I_J((_1 - 1),_2)]) +
               _Solution_I_J_pointer[SC_Solution_I_J(_1,(_2 + 1))]) +
               _Solution_I_J_pointer[SC_Solution_I_J(_1,(_2 - 1))]) +
               _Solution_I_J_pointer[SC_Solution_I_J((_1 + 1),(_2 + 1))]) +
               _Solution_I_J_pointer[SC_Solution_I_J((_1 + 1),(_2 - 1))]) +
               _Solution_I_J_pointer[SC_Solution_I_J((_1 - 1),(_2 + 1))]) +
               _Solution_I_J_pointer[SC_Solution_I_J((_1 - 1),(_2 - 1))]) / 8.0; 
          }
        } 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _Solution_I_J_pointer[SC_Solution_I_J(_1,_2)] = __T_I_J_pointer[SC__T_I_J(_1,_2)]; 
          } 
        } 

     return 0;
} 

\end{lstlisting}

% \newpage
\subsubsection{Stencil with Loop Dependence with Transformation Assertions}
\begin{lstlisting}{}

int functionD()
   { 
     ARRAY_OPERAND_UNIFORM_SIZE_DECLARATION_MACRO_D2(); 
     double * _Right_Hand_Side_I_J_pointer = ((double * )0); 
     double * _Solution_I_J_pointer = ((double * )0); 
     double * __T_I_J_pointer = ((double * )0); 
     int _1; 
     int _2; 
     int _length1 = 0; 
     int _length2 = 0; 
     class doubleArray _T; 
  // First optimization permits all the size# variables to be the same across all operands (this
  // should significantly reduce the registar pressure).
     class TransformationAssertion assertion1(TransformationAssertion::SameSizeArrays); 

  // Specification of uniform stride permits all the <name>_stride# variables to be the same across
  // all operands (further reducing the register pressure).
     class TransformationAssertion assertion2(TransformationAssertion::ConstantStrideAccess); 

  // In addition to uniform stride we specify here that the stride is lenght 1 which permits
  // additional optimizations to the subscript computation (or the loop nest) to remove the stride
  // variable from the computations altogether.
     class TransformationAssertion assertion3(TransformationAssertion::StrideOneAccess); 

     int n;
     class Range I;
     class Range J;
     class Range K;
     class doubleArray Right_Hand_Side(n,n);
     class doubleArray Solution(n,n);
     double Mesh_Size; 
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
;
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(Solution); 
     _Right_Hand_Side_I_J_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J); 
     _Solution_I_J_pointer = (Solution.getAdjustedDataPointer)(I,J); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(I,J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(Solution); 
     _T.redim(Solution); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC(_1,_2)] =
               (((((((((Mesh_Size * Mesh_Size) * _Right_Hand_Side_I_J_pointer[SC(_1,_2)] +
               _Solution_I_J_pointer[SC((_1 + 1),_2)]) + _Solution_I_J_pointer[SC((_1 - 1),_2)]) +
               _Solution_I_J_pointer[SC(_1,(_2 + 1))]) + _Solution_I_J_pointer[SC(_1,(_2 - 1))]) +
               _Solution_I_J_pointer[SC((_1 + 1),(_2 + 1))]) + _Solution_I_J_pointer[SC((_1 + 1),(_2 - 1))]) +
               _Solution_I_J_pointer[SC((_1 - 1),(_2 + 1))]) + _Solution_I_J_pointer[SC((_1 - 1),(_2 - 1))]) / 8.0; 
          } 
        } 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _Solution_I_J_pointer[SC(_1,_2)] = __T_I_J_pointer[SC(_1,_2)]; 
          } 
        } 

     return 0;
   } 

\end{lstlisting}

\subsection{Transformations of multiple Statements}

    Transformations on multiple statements can be handled in at least two ways.
\begin{enumerate}
   \item Each statement transformation in its own scope.
   \item Each statement transformation in its original scope.
\end{enumerate}

   The \axx preprocessor can generate transformation in each of these forms.  The examples below
show the slightly more complex generation of transformation in their original scope.  Transformation
appearing in their own scope are more complex because they have to be organized more carefully,
transformation specifications are divided into:
\begin{enumerate}
   \item Supporting Declarations for internal compilation.

   \item Supporting local variable declarations for the final transformation (as it appears in the
   final output code).

   \item Supporting variable initializations.

   \item The source code representing the transformation (separate from supporting variable
   declarations and initializations).
\end{enumerate}

The classification and organization of the transformations for generation within the original scope
also sets up the required organization required for loop fusion later (requiring dependence
analysis, not currently implemented).

\subsubsection{Original array statements before transformation}

The following array statments are used as a basis for the examples that show multiple statement
transformations.

\begin{lstlisting}{}
     int m,n; \
     InternalIndex I,J,K,L; \
     doubleArray A(10,10); \
     doubleArray B(10,10); \
     A      = 0; \
     A(I,J) = 0; \
     A(I,J) = B(I-1,J+1); \
     A(I+(m*2),J+(m-1)) = B(1+(I-(n+4)),J) + B(I+n,J+m); \
     A(I,J) = A(I-1,J); \
     A(I,J) = A(I-1,J) + A(I+1,J); \
     A(I,J) = A(I-1,J) + A(I+1,J) + n; \

\end{lstlisting}

\subsubsection{Multiple Statement Transformation Example (no transformation assertions)}

   The following code demonstrates the transformations of multiple statements.  The code
representing the transformation specification is divided into supporting declarations and
initializations.  The declarations are collected at the top of the scope while the variable
initializations required to support the transformation are positioned between the transformation
source code (loop nests).

\begin{lstlisting}{}
int functionA()
   { 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(_B); 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D2(__T); 
     ARRAY_OPERAND_VARIABLE_SIZE_DECLARATION_MACRO_D6(_A); 
     double * _A_I_J_pointer = ((double * )0); 
     double * _A_pointer = ((double * )0); 
     double * _B_I_J_pointer = ((double * )0); 
     double * __T_I_J_pointer = ((double * )0); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(_A_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(_B_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D2(__T_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_DECLARATION_MACRO_D6(_A); 
     int _1; 
     int _2; 
     int _3; 
     int _4; 
     int _5; 
     int _6; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
     int _length4 = 0; 
     int _length5 = 0; 
     int _length6 = 0; 
     class doubleArray _T;
     int m;
     int n;
     class InternalIndex I;
     class InternalIndex J;
     class InternalIndex K;
     class InternalIndex L;
     class doubleArray A(10,10);
     class doubleArray B(10,10); 
     #define SC_A(x1,x2,x3,x4,x5,x6) /* case VariableSizeVariableStride */ \
          (x1)*_A_stride1+((x2)*_A_stride2*_A_size1)+((x3)*_A_stride3*_A_size2)+\
         ((x4)*_A_stride4*_A_size3)+((x5)*_A_stride5*_A_size4)+((x6)*_A_stride6*_A_size5)
;
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D6(A,_A); 
     _A_pointer = (A.getAdjustedDataPointer)(); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D6(A,_A); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D6(A); 
     for (_6 = 0; _6 < _length6; _6++)
        { 
          for (_5 = 0; _5 < _length5; _5++)
          { 
            for (_4 = 0; _4 < _length4; _4++)
            { 
              for (_3 = 0; _3 < _length3; _3++)
              { 
                for (_2 = 0; _2 < _length2; _2++)
                { 
                  for (_1 = 0; _1 < _length1; _1++)
                  { 
                    _A_pointer[SC_A(_1,_2,_3,_4,_5,_6)] = 0.0; 
                  } 
                } 
              } 
            } 
          } 
        } 
        
     #define SC_A_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_A_I_J_stride1+((x2)*_A_I_J_stride2*_A_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(A,_A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(A,_A_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC_A_I_J(_1,_2)] = 0.0; 
          } 
        } 
        
     #define SC_A_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_A_I_J_stride1+((x2)*_A_I_J_stride2*_A_size1)
; 
        
     #define SC_B_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_B_I_J_stride1+((x2)*_B_I_J_stride2*_B_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(A,_A); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(B,_B); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     _B_I_J_pointer = (B.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(A,_A_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(B,_B_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC_A_I_J(_1,_2)] = _B_I_J_pointer[SC_B_I_J((_1 - 1),(_2 + 1))]; 
          } 
        } 
        
     #define SC_A_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_A_I_J_stride1+((x2)*_A_I_J_stride2*_A_size1)
; 
        
     #define SC_B_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_B_I_J_stride1+((x2)*_B_I_J_stride2*_B_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(A,_A); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(B,_B); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     _B_I_J_pointer = (B.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(A,_A_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(B,_B_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC_A_I_J((_1 + m * 2),((_2 + m) - 1))] = _B_I_J_pointer[SC_B_I_J((1
             + ((_1 - n) + 4)),_2)] + _B_I_J_pointer[SC_B_I_J((_1 + n),(_2 + m))]; 
          } 
        } 
        
     #define SC_A_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_A_I_J_stride1+((x2)*_A_I_J_stride2*_A_size1)
; 
        
     #define SC__T_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*__T_I_J_stride1+((x2)*__T_I_J_stride2*__T_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(A,_A); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(_T,__T); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(A,_A_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(_T,__T_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     _T.redim(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC__T_I_J(_1,_2)] = _A_I_J_pointer[SC_A_I_J((_1 - 1),_2)]; 
          } 
        } 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC_A_I_J(_1,_2)] = __T_I_J_pointer[SC__T_I_J(_1,_2)]; 
          } 
        } 
        
     #define SC_A_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_A_I_J_stride1+((x2)*_A_I_J_stride2*_A_size1)
; 
        
     #define SC__T_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*__T_I_J_stride1+((x2)*__T_I_J_stride2*__T_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(A,_A); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(_T,__T); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(A,_A_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(_T,__T_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     _T.redim(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC__T_I_J(_1,_2)] = _A_I_J_pointer[SC_A_I_J((_1 - 1),_2)]
             + _A_I_J_pointer[SC_A_I_J((_1 + 1),_2)]; 
          } 
        } 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC_A_I_J(_1,_2)] = __T_I_J_pointer[SC__T_I_J(_1,_2)]; 
          } 
        } 
        
     #define SC_A_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*_A_I_J_stride1+((x2)*_A_I_J_stride2*_A_size1)
; 
        
     #define SC__T_I_J(x1,x2) /* case VariableSizeVariableStride */ \
          (x1)*__T_I_J_stride1+((x2)*__T_I_J_stride2*__T_size1)
; 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(A,_A); 
     ARRAY_OPERAND_VARIABLE_SIZE_INITIALIZATION_MACRO_D2(_T,__T); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(A,_A_I_J); 
     ARRAY_OPERAND_VARIABLE_STRIDE_INITIALIZATION_MACRO_D2(_T,__T_I_J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     _T.redim(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC__T_I_J(_1,_2)] = (_A_I_J_pointer[SC_A_I_J((_1 - 1),_2)]
             + _A_I_J_pointer[SC_A_I_J((_1 + 1),_2)]) + n; 
          } 
        } 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC_A_I_J(_1,_2)] = __T_I_J_pointer[SC__T_I_J(_1,_2)]; 
          } 
        } 

     return 0;
   } 

\end{lstlisting}

% \subsubsection{Multiple Statement Transformation Example (with transformation assertions)}
\subsubsection{Multiple Statement Transformation Example with transformation assertions (SameSizeArrays \&\& ConstantStrideAccess \&\& stride == 1)}

\begin{lstlisting}{}
int functionD()
   { 
     ARRAY_OPERAND_UNIFORM_SIZE_DECLARATION_MACRO_D6(); 
     double * _A_I_J_pointer = ((double * )0); 
     double * _A_pointer = ((double * )0); 
     double * _B_I_J_pointer = ((double * )0); 
     double * __T_I_J_pointer = ((double * )0); 
     int _1; 
     int _2; 
     int _3; 
     int _4; 
     int _5; 
     int _6; 
     int _length1 = 0; 
     int _length2 = 0; 
     int _length3 = 0; 
     int _length4 = 0; 
     int _length5 = 0; 
     int _length6 = 0; 
     class doubleArray _T; 

  // First optimization permits all the size# variables to be the same across all operands (this
  // should significantly reduce the registar pressure).
     class TransformationAssertion assertion1(TransformationAssertion::SameSizeArrays); 

  // Specification of uniform stride permits all the <name>_stride# variables to be the same across
  // all operands (further reducing the register pressure).
     class TransformationAssertion assertion2(TransformationAssertion::ConstantStrideAccess); 

  // In addition to uniform stride we specify here that the stride is lenght 1 which permits
  // additional optimizations to the subscript computation (or the loop nest) to remove the stride
  // variable from the computations altogether.
     class TransformationAssertion assertion3(TransformationAssertion::StrideOneAccess); 

     int m;
     int n;
     class InternalIndex I;
     class InternalIndex J;
     class InternalIndex K;
     class InternalIndex L;
     class doubleArray A(10,10);
     class doubleArray B(10,10); 
     #define SC(x1,x2,x3,x4,x5,x6) /* case UniformSizeUnitStride */ \
          (x1)+(x2)*_size1+(x3)*_size2+(x4)*_size3+(x5)*_size4+(x6)*_size5
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D6(A); 
     _A_pointer = (A.getAdjustedDataPointer)(); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D6(A); 
     for (_6 = 0; _6 < _length6; _6++)
        { 
          for (_5 = 0; _5 < _length5; _5++)
          { 
            for (_4 = 0; _4 < _length4; _4++)
            { 
              for (_3 = 0; _3 < _length3; _3++)
              { 
                for (_2 = 0; _2 < _length2; _2++)
                { 
                  for (_1 = 0; _1 < _length1; _1++)
                  { 
                    _A_pointer[SC(_1,_2,_3,_4,_5,_6)] = 0.0; 
                  } 
                } 
              } 
            } 
          } 
        } 
        
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC(_1,_2)] = 0.0; 
          } 
        } 
        
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     _B_I_J_pointer = (B.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC(_1,_2)] = _B_I_J_pointer[SC((_1 - 1),(_2 + 1))]; 
          } 
        } 
        
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     _B_I_J_pointer = (B.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC((_1 + m * 2),((_2 + m) - 1))] = _B_I_J_pointer[SC((1 + ((_1
             - n) + 4)),_2)] + _B_I_J_pointer[SC((_1 + n),(_2 + m))]; 
          } 
        } 
        
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     _T.redim(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC(_1,_2)] = _A_I_J_pointer[SC((_1 - 1),_2)]; 
          } 
        } 
        for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC(_1,_2)] = __T_I_J_pointer[SC(_1,_2)]; 
          } 
        } 
        
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     _T.redim(A); 
        for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC(_1,_2)] = _A_I_J_pointer[SC((_1 - 1),_2)] + _A_I_J_pointer[SC((_1
             + 1),_2)]; 
          } 
        } 
        for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC(_1,_2)] = __T_I_J_pointer[SC(_1,_2)]; 
          } 
        } 
        
     #define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
     ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(A); 
     _A_I_J_pointer = (A.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     __T_I_J_pointer = (_T.getAdjustedDataPointer)(((const InternalIndex & )I),((const InternalIndex & )J)); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(A); 
     _T.redim(A); 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC(_1,_2)] = (_A_I_J_pointer[SC((_1 - 1),_2)] + _A_I_J_pointer[SC((_1
             + 1),_2)]) + n; 
          } 
        } 
     for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _A_I_J_pointer[SC(_1,_2)] = __T_I_J_pointer[SC(_1,_2)]; 
          } 
        } 

     return 0;
   } 

\end{lstlisting}

\subsection{Unformatted example output from \axx preprocessor (current status of unparser)}

   The examples presented in this talk have been slightly reformated by hand to make them more presentable.
The current status of the ROSE unparser is that it does not output code is such a pretty format.  Included
below is an example of the previous code as it is output (unparsed) by the \axx preprocessor.  Notice that
it is roughtly formatted but with a few too many linefeeds and a few in strange places.

\begin{lstlisting}{}

int functionD()
   { 
     ARRAY_OPERAND_UNIFORM_SIZE_DECLARATION_MACRO_D2(); 
     double * _Right_Hand_Side_I_J_pointer = ((double * )0); 
double * _Solution_I_J_pointer = ((double * )0); 
double * __T_I_J_pointer = ((double * )0); 
int _1; 
int _2; 
int _length1 = 0; 
int _length2 = 0; 
class doubleArray _T; 
// First optimization permits all the size# variables to be the same across all operands (this

// should significantly reduce the registar pressure).

     class TransformationAssertion assertion1(TransformationAssertion::SameSizeArrays); 

// Specification of uniform stride permits all the <name>_stride# variables to be the same across

// all operands (further reducing the register pressure).


     class TransformationAssertion assertion2(TransformationAssertion::ConstantStrideAccess); 

// In addition to uniform stride we specify here that the stride is lenght 1 which permits

// additional optimizations to the subscript computation (or the loop nest) to remove the stride

// variable from the computations altogether.


     class TransformationAssertion assertion3(TransformationAssertion::StrideOneAccess); 

 int n; class Range I; class Range J; class Range K; class doubleArray Right_Hand_Side(n,n); class doubleArray Solution(n,n); double Mesh_Size; 
#define SC(x1,x2) /* case UniformSizeUnitStride */ (x1)+(x2)*_size1
; 
        ARRAY_OPERAND_UNIFORM_SIZE_INITIALIZATION_MACRO_D2(Solution); 
        _Right_Hand_Side_I_J_pointer = (Right_Hand_Side.getAdjustedDataPointer)(I,J); 
        _Solution_I_J_pointer = (Solution.getAdjustedDataPointer)(I,J); 
        __T_I_J_pointer = (_T.getAdjustedDataPointer)(I,J); 
     ARRAY_TRANSFORMATION_LENGTH_INITIALIZATION_MACRO_D2(Solution); 
     _T.redim(Solution); 
        for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            __T_I_J_pointer[SC(_1,_2)] =
               (((((((((Mesh_Size * Mesh_Size) * _Right_Hand_Side_I_J_pointer[SC(_1,_2)] + 
               _Solution_I_J_pointer[SC((_1 + 1),_2)]) + _Solution_I_J_pointer[SC((_1 - 1),_2)]) +
               _Solution_I_J_pointer[SC(_1,(_2 + 1))]) + _Solution_I_J_pointer[SC(_1,(_2 - 1))]) +
               _Solution_I_J_pointer[SC((_1 + 1),(_2 + 1))]) + _Solution_I_J_pointer[SC((_1 + 1),(_2 - 1))]) +
               _Solution_I_J_pointer[SC((_1 - 1),(_2 + 1))]) + _Solution_I_J_pointer[SC((_1 - 1),(_2 - 1))]) / 8.0; 
          } 
        } 
        for (_2 = 0; _2 < _length2; _2++)
        { 
          for (_1 = 0; _1 < _length1; _1++)
          { 
            _Solution_I_J_pointer[SC(_1,_2)] = __T_I_J_pointer[SC(_1,_2)]; 
          } 
        } 



     return 0;
} 


\end{lstlisting}


% \newpage
\section{Current Limitations}
    This section covers some of the current limitations and known bugs in the initial release of the \axx preprocessor.

\begin{itemize}
   \item Some example might only work for doubleArray objects because the sinpleA++.h file
   containing a simplified set of headers to speed the processing of intermediate files to generate
   AST fragements is incomplete.


\end{itemize}

\subsection{Types of statements that are not likely to work}

   The following are examples of array statements that are not likely to work because they require features not yet implemented in the preprocessor.

\begin{itemize}
   \item Indirect addressing
   \item {\tt where} statements
   \item Indexing using mixed scalar and index or Range objects
\end{itemize}

   Examples of array statements that should not presently work:
\vspace{0.5in}

\begin{lstlisting}{}


doubleArray A(10);
doubleArray B(10);
doubleArray C(10);

// Mixed Index object and scalar indexing
A(I,J,0) = 2;

// no mechanism for naming (B+C) though (B+C)(I) == B(I) + C(I) would simplify the expression and
// permit it to be optimized.
A(I) = (B+C)(I);

// requires simplified expression editing mechanism in ROSE (beyond that available in SAGE)
// transformation would be T = foo(B); A = T + C;
A = foo(B) + C;
foo(A) = B;

// Prefix and postfix operators are not distinguished (default is postfix)
A++;

// array expressions that appear in index expressions
A (I+sum(A)) = 0;

\end{lstlisting}


\end{document}



















