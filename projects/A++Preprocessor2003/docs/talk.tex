\documentclass[10pt]{llncs}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{amsmath}

% Fixme margin note package (turn on draft mode)
% \usepackage[final]{fixme}
% \usepackage[draft]{fixme}

\usepackage{color,listings}
\lstloadlanguages{APP}


\psfigdriver{dvips}

% New commands
\newcommand{\commentout}[1]{}

% change the title of the Fixme List
% \renewcommand{\listfixmename}{Things to Fix}

\newcommand{\comm}[2]{\bigskip
                      \begin{tabular}{|p{11cm}|}\hline
                      \multicolumn{1}{|c|}{{\bf Comment by #1}}\\ \hline
                      #2\\ \hline
                      \end{tabular}
                      \bigskip
                     }

\addtolength{\oddsidemargin}{-1.0in}
\addtolength{\evensidemargin}{-1.0in}
\addtolength{\textwidth}{2.0in}
\addtolength{\topmargin}{-0.5in}
\addtolength{\textheight}{1.5in}

% \pagenumbering{roman}
% \pagestyle{empty}
% \setcounter{page}{0}
% \thispagestyle{empty}

\sloppy

%---------------------------------------------------------------------
% Begin Document
%---------------------------------------------------------------------

\commentout{ Outline for Paper }

\begin{document}

\title{ Introduction to P++ (DRAFT DOCUMENT) }
\author{Daniel J.\ Quinlan }
\institute{Center for Applied Scientific Computing\\
Lawrence Livermore National Laboratory, Livermore, CA, USA\\
}

\date{}

\maketitle

\begin{abstract}
   Talk on P++.
\end{abstract}

\lstset{
 % language=C++,
   language=APP,
 % basicstyle=\small,                 % print whole listing small
   basicstyle=\scriptsize,            % print whole listing scriptsize
 % keywordstyle=\color{red}\bfseries\underbar, % underlined bold red keywords
 % keywordstyle=\bfseries\underbar, % underlined bold red keywords
   keywordstyle=\color{red}\bfseries, % underlined bold red keywords
   ndkeywordstyle=\color{blue}, % underlined bold red keywords
 % rdkeywordstyle=\color{blue}, % underlined bold red keywords
   identifierstyle={},                % nothing happens to other identifiers
 % identifierstyle=\color{blue},                % nothing happens to other identifiers
   commentstyle=\color{green},                % nothing happens to other identifiers
 % stringstyle=\ttfamily,             % typerwriter type for strings
 % stringstyle=\color{cyan}\ttfamily,             % typerwriter type for strings Magenta
   stringstyle=\color{magenta}\ttfamily,             % typerwriter type for strings Magenta
   stringspaces=false,                % no special string spaces
   labelstyle=\scriptsize,
   labelstep=1,
   labelsep=10pt
}

\section{Introduction}

    This introduction to P++ will cover the details of what happends when to arrays are added together
and assigned to a third array.  The canonical example being: 
$$ A = B + C; $$

Of course this is complicated in the parallel environment by A, B, and C each being distributed in some
arbitrary way across different processors.

To present the arial view of what our canonical example requires I will show some of the code which
implements a few of the high level operations. Specifially the operator+, operator=, and the
abstract operators which support all binary operators (there are actually 7-10 of these abstract
operators, for simplicity I will show only one of them).

   P++ is implemnted on top of A++, each P++ array object contains an A++ array object as a data member.
In general, operations on P++ array objects are performed first by generating the serial arrays for a 
local A++ operations and then calling A++ array operators explicitly.  The generation of the serial
array input for the local A++ operations is generally performed by the PCE support.

  A significant function which I will discuss but I have left out of this introduction is the
Parallel Conformability Enforcement (PCE) support.  This function is just too long and complex to
present, even if it is largely the heart of P++ as an idea and as an implementation.  It is however,
where most of the magic happens.

\section{The Binary Addition Operator}

   This operator takes two arrays and generates their sum as a third array.  If either of the
the two inputs are temporaries (results from previously executed operators) then we have special
handling to avoid redundent generation of temporaries (we reuse the temporaries).

   This code is both the A++ and P++ code, depending upon if {\bf PPP} is defined or not.

\vspace{0.5in}

\begin{lstlisting}{}
doubleArray &
operator+ ( const doubleArray & Lhs , const doubleArray & Rhs )
   {
#if COMPILE_DEBUG_STATEMENTS
  // This is the only test we can do on the input!
     Lhs.Test_Consistency ("Test Lhs in operator+");
     Rhs.Test_Consistency ("Test Rhs in operator+");
#endif

  // Are the arrays the same size (otherwise issue error message and stop).
     if (Index::Index_Bounds_Checking)
          Lhs.Test_Conformability (Rhs);

#if defined(PPP)
     doubleSerialArray* Lhs_SerialArray = NULL;
     doubleSerialArray* Rhs_SerialArray = NULL;

     intSerialArray* Mask_SerialArray = NULL;
     intSerialArray* Old_Mask_SerialArray = NULL;

     Array_Conformability_Info_Type *Temporary_Array_Set = NULL;
     if (Where_Statement_Support::Where_Statement_Mask == NULL)
        {
          if ((Lhs.Array_Descriptor.Array_Domain.Uses_Indirect_Addressing == TRUE) ||
	      (Rhs.Array_Descriptor.Array_Domain.Uses_Indirect_Addressing == TRUE))
             {
               Temporary_Array_Set = doubleArray :: Parallel_Indirect_Conformability_Enforcement ( Lhs, Lhs_SerialArray, Rhs, Rhs_SerialArray );
             }
            else
             {
               Temporary_Array_Set = doubleArray :: Parallel_Conformability_Enforcement ( Lhs, Lhs_SerialArray, Rhs, Rhs_SerialArray );
             }
        }
       else
        {
          Old_Mask_SerialArray = Where_Statement_Support :: Where_Statement_Mask->getSerialArrayPointer();
          if ( (Lhs.Array_Descriptor.Array_Domain.Uses_Indirect_Addressing == TRUE) ||
               (Rhs.Array_Descriptor.Array_Domain.Uses_Indirect_Addressing == TRUE) )
             {
               printf ("Sorry, not implemented: can't mix indirect addressing using where statements and two array (binary) operators!\n");
               APP_ABORT();
             }
            else
             {
               Temporary_Array_Set = doubleArray :: Parallel_Conformability_Enforcement
                  (Lhs, Lhs_SerialArray, *Where_Statement_Support :: Where_Statement_Mask, Mask_SerialArray, Rhs, Rhs_SerialArray );
             }
          *Where_Statement_Support :: Where_Statement_Mask->getSerialArrayPointerLoc() = Mask_SerialArray;
        }

     if (Temporary_Array_Set == NULL)
          Temporary_Array_Set = new Array_Conformability_Info_Type();

     APP_ASSERT(Temporary_Array_Set != NULL);
     APP_ASSERT(Lhs_SerialArray != NULL);
     APP_ASSERT(Rhs_SerialArray != NULL);

     bool lhsIsTemporary = Lhs_SerialArray->isTemporary();
     bool rhsIsTemporary = Rhs_SerialArray->isTemporary();

     APP_ASSERT ( (lhsIsTemporary == TRUE) || (lhsIsTemporary == FALSE) );
     APP_ASSERT ( (rhsIsTemporary == TRUE) || (rhsIsTemporary == FALSE) );

     doubleArray & Return_Value = doubleArray :: Abstract_Operator 
	( Temporary_Array_Set, Lhs, Rhs, Lhs_SerialArray, Rhs_SerialArray, *Lhs_SerialArray + *Rhs_SerialArray );

  // Check for reuse of serialArray object in return value (do not delete it if it was reused)
     if (lhsIsTemporary == FALSE)
        {
       // Only delete the serial array data when the Overlap update model is used
       // Must delete the Lhs_SerialArray if it was taken directly from the Lhs array!
       // Added conventional mechanism for reference counting control
       // operator delete no longer decriments the referenceCount.
          APP_ASSERT (Lhs_SerialArray->getReferenceCount() >= intSerialArray :: getReferenceCountBase());
          Lhs_SerialArray->decrementReferenceCount();
          if (Lhs_SerialArray->getReferenceCount() < intSerialArray :: getReferenceCountBase())
             {
               delete Lhs_SerialArray;
             }
          Lhs_SerialArray = NULL;

        }

     if (rhsIsTemporary == FALSE)
        {
       // Only delete the serial array data when the Overlap update model is used
       // Must delete the Rhs_SerialArray if it was taken directly from the Rhs array!
       // Added conventional mechanism for reference counting control
       // operator delete no longer decriments the referenceCount.
          APP_ASSERT (Rhs_SerialArray->getReferenceCount() >= intSerialArray :: getReferenceCountBase());
          Rhs_SerialArray->decrementReferenceCount();
          if (Rhs_SerialArray->getReferenceCount() < intSerialArray :: getReferenceCountBase())
             {
               delete Rhs_SerialArray;
             }
          Rhs_SerialArray = NULL;

        }

     if (Where_Statement_Support :: Where_Statement_Mask != NULL)
        {
          *Where_Statement_Support :: Where_Statement_Mask->getSerialArrayPointerLoc() = Old_Mask_SerialArray; 
       // Added conventional mechanism for reference counting control
       // operator delete no longer decriments the referenceCount.
          Mask_SerialArray->decrementReferenceCount();
          if (Mask_SerialArray->getReferenceCount() < intSerialArray :: getReferenceCountBase())
               delete Mask_SerialArray;
          Mask_SerialArray = NULL;
        }

  // Delete the Temporary_Array_Set
     APP_ASSERT (Temporary_Array_Set->getReferenceCount() >= Array_Conformability_Info_Type :: getReferenceCountBase());
     Temporary_Array_Set->decrementReferenceCount();
     if (Temporary_Array_Set->getReferenceCount() < Array_Conformability_Info_Type :: getReferenceCountBase())
        {
          delete Temporary_Array_Set;
        }
     Temporary_Array_Set = NULL;

     return Return_Value;
#else
     return doubleArray :: Abstract_Binary_Operator ( Lhs , Rhs , 
               MDI_d_Add_Array_Plus_Array,
               MDI_d_Add_Array_Plus_Array_Accumulate_To_Operand , doubleArray :: Plus );
#endif
   }

\end{lstlisting}

% \end{document}

\newpage
\section{Array Assignment}
    Shown below are the serial and parallel assignment operators.

\subsection{Serial Assignment Operator}
   
    If the details of A++ are to be ignored then discussion of this operator can be skipped.
It is included to show some of the complexity of a relatively simple assignment operation.
The A++ (or SerialArray) assignment operator is used internally in P++.

\vspace{0.5in}

\begin{lstlisting}{}
doubleSerialArray & 
doubleSerialArray :: operator= ( const doubleSerialArray & Rhs )
   {
  // This function is only called once for each Array statment!

#if COMPILE_DEBUG_STATEMENTS
     Test_Consistency("Test Lhs in doubleSerialArray :: operator=");
     Rhs.Test_Consistency("Test Rhs in doubleSerialArray :: operator=");
#endif

     if (Index :: Index_Bounds_Checking)
          Test_Conformability (Rhs);

#if COMPILE_DEBUG_STATEMENTS
     if (isTemporary() == TRUE)
        {
          printf ("ERROR: Assignment to a temporary makes little sence so it has been ");
          printf ("disallowed! \n");
          printf ("       If you really feel you need this sort of functionality then ");
          printf ("let me know ... Dan Quinlan \n");
          APP_ABORT();
       }
#endif

     if (Expression_Tree_Node_Type :: DEFER_EXPRESSION_EVALUATION)
        {
       // Check to see if the operator()() is used otherwise we do the assignment!
       // The function Binary_Conformable returns false if the "where" mask is present!
          if ( Binary_Conformable (Rhs) && Rhs.isTemporary() )
             {
               Add_Defered_Expression ( new doubleSerialArray_Function_Steal_Data ( Assignment , *this , Rhs ) );
             }
            else
             {
               Add_Defered_Expression ( new doubleSerialArray_Function_3 ( Assignment , MDI_d_Assign_Array_Equals_Array_Accumulate_To_Operand , *this , Rhs ) );
             }
        }
       else
        {
       // BUG FIX (July 29 1993; dquinlan)!
       // These can't be reference variables since they are then not initialized 
       // properly so they are implemented as pointers to pointers to the array data!
          double** Lhs_Data_Pointer = &(Array_Descriptor.Array_Data);
          double** Rhs_Data_Pointer = &(((doubleSerialArray &)Rhs).Array_Descriptor.Array_Data);

       // Notice that we assume that the mask might be a view!
          int* Mask_Array_Data = NULL;
          array_domain* Mask_Descriptor = NULL;

          if (Where_Statement_Support :: Where_Statement_Mask != NULL)
             {
#if defined(SERIAL_APP)
            // error checking
            APP_ASSERT(Where_Statement_Support :: Serial_Where_Statement_Mask == NULL);

            // The serial array class does not have access to the data (this is a 
	    // permission probem I have to fix) 
               Mask_Array_Data = Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray->getDataPointer();
               Mask_Descriptor = (array_domain*) Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray->getDomainPointer();
            // Are the arrays the same size (otherwise issue error message and stop).
               if (Index :: Index_Bounds_Checking)
                    Test_Conformability (*Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray);
#else
               Mask_Array_Data = Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.Array_Data;
               Mask_Descriptor = (array_domain*) &(Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.Array_Domain);
            // Are the arrays the same size (otherwise issue error message and stop).
               if (Index :: Index_Bounds_Checking)
                    Test_Conformability (*Where_Statement_Support :: Where_Statement_Mask);
#endif

             }
#if defined(SERIAL_APP)
	     else if (Where_Statement_Support :: Serial_Where_Statement_Mask != NULL)
	     {
               Mask_Array_Data = Where_Statement_Support :: 
		  Serial_Where_Statement_Mask->Array_Descriptor.Array_Data;
               Mask_Descriptor = (array_domain*)(&Where_Statement_Support :: 
		  Serial_Where_Statement_Mask->Array_Descriptor.Array_Domain);
               // Are the arrays the same size (otherwise issue error message and 
	       // stop).
               if (Index :: Index_Bounds_Checking)
                  Test_Conformability 
		     (*Where_Statement_Support :: Serial_Where_Statement_Mask);
	     }
#endif


       // Check to see if one of the operator()() is used otherwise we do the 
       // assignment!  The function Binary_Conformable returns false if the "where" 
       // mask is present! This works independent of the reference counting (I think)!
          if ( (getRawDataReferenceCount() == getRawDataReferenceCountBase()) &&
                Binary_Conformable (Rhs) && 
                Rhs.isTemporary() &&
               !Rhs.isView() )
             {
            // Give back the original Array_Data memory (but only if it exists)!
            // But it should always exist so we don't really have to check unless it is 
	    // a Null array!

            /*
            // ... bug fix (8/26/96, kdb) this was previously called later
            // after deleteing the Array_Descriptor but because the data
            // wasn't deleted, the reference count in
            // Array_Reference_Count_Array[Array_Id] was too high and so
            // the Array_ID wasn't put back onto the list ...
            */
               Delete_Array_Data ();

               if (isNullArray())
                  {
                 // Bug Fix (8/17/94) Even a Null array must have a properly computed array descriptor
                    APP_ASSERT(isTemporary() == FALSE);

                 // We know it is a temporary because we only try to steal temporaries
                 // so check to temporaries that are a view -- but we don't allow views
                 // so it CAN'T be a view.
                    APP_ASSERT(Rhs.isView() == FALSE);

                 // We have to reset the reference count since the operator= used in the Build_Temporary_By_Example function
                 // will get trapped in the test_Consistancy test if we don't.
                    resetRawDataReferenceCount();
                    Array_Descriptor.Build_Temporary_By_Example (Rhs.Array_Descriptor);

                 // This is redundent since the base of the temporary is already set to ZERO!
                 // setBase(0);
                    APP_ASSERT (getBase() == 0);

                 // This is no longer going to be a temporary so mark it as a non temporary
                 // Array_Descriptor.Array_Domain.Is_A_Temporary = FALSE;
                    setTemporary(FALSE);

                 // Double check to make sure it is not a view
                    APP_ASSERT( isView() == FALSE );
                  }

            // ... bug fix (8/26/96,kdb) see comment above ...
            // Delete_Array_Data ();
               *Lhs_Data_Pointer = NULL;

            // BUG FIX: (18/1/94) fixed reference counts.
            // Reset the reference count to zero as we steal the data because the 
            // new data should have a reference count of zero (not -1 as would be 
            // the case if it had been deleted)! setting it to ZERO means there are
            // NO (ZERO) external references to this data (only the one by this array 
            // object).

            // I don't want to provide a means to reset or assign specific reference 
            // counts (dangerous I think)

            // Steal the pointer (to the original array) from the Rhs's data
            // Note that these are REFERENCE variables!
               *Lhs_Data_Pointer = *Rhs_Data_Pointer;

            // ... change (8/21/96,kdb) Add eight view pointers ...
               POINTER_LIST_INITIALIZATION_MACRO;

            // Since the previous copy of the array data was deleted the reference count 
	    // of the Raw Data is not -1 (typically) so we have to reset it.  We could 
            // just increment it -- but error checking within the 
            // incrementRawDataReferenceCount would trap out the case where the
            // reference count of the raw data is less than ZERO.  So we have a special 
            // inline function to force the reset value to ZERO.

               resetRawDataReferenceCount();

            // We can set the correct one by using the fact that 
            // Rhs_Data_Pointer is a pointer to a pointer to the array data!

            // ... (bug fix, 6/27/96, kdb) don't set this pointer to null here
            // because otherwise the array won't be deleted.  Also increment
            // the reference count for Rhs so Array_Data won't be deleted ...
               Rhs.incrementRawDataReferenceCount();

            /*
            // ... the Array_Descriptor will be deleted but because the
	    // Array_Reference_Count_Array was just incremented the array ID
            // won't be put back in the list like it should be.  Before
            // deleting, force the array ID onto the stack.  The 
            // Array_Reference_Count_Array[Array_ID] will already be 0 after
            // the delete.  (This problem comes up because of the assumption
            // that the only time 2 arrays share Array_Data is when one is a
            // view of another and so has the same Array_ID) ...
            */

            // get the array id of the Rhs before it is deleted
               int rhsArrayID = Rhs.Array_ID();

            // The Rhs will be deleted but until then we can't really call any
            // of it's member functions since there is no data associated with it.
            // printf ("In doubleSerialArray :: operator= calling Delete_If_Temporary ( Rhs ) \n");
               Delete_If_Temporary ( Rhs );

            // Bugfix (11/7/2000) 
            // Move to after the call to Delete_If_Temporary() since that function 
            // calls the Test_Consistency function which will report an error if the 
            // array ID is pushed onto the stack while it is a valid array ID still in use.
            // Bugfix (11/6/2000) Deleting the array should put it back onto 
            // the stack of array ID for future use (I think).
            // Bugfix (11/11/2000) accessing data after it is deleted
               Rhs.Array_Descriptor.Array_Domain.Push_Array_ID(rhsArrayID);

            // Bugfix (12/6/2000) Also reset the reference count associated with this id value!
               SerialArray_Domain_Type :: Array_Reference_Count_Array [rhsArrayID] = getRawDataReferenceCountBase() - 1;

            // Now we have to delete the "this" object if it is a View! But we are the 
            // this object so we have to be very carefull how this is done!
            // printf ("In doubleSerialArray :: operator= calling Delete_Lhs_If_Temporary ( *this ) \n");
               Delete_Lhs_If_Temporary ( *this );
             }
            else // Do the assignment the hard way (element by element)!
             {
            /* Call Assignment function
            // The function name that we call here is slightly effected by the fact that 
	    // we use a marco processor to generate the machine dependent functions a 
            // better name would have been "Assign_Array_Data_Equals_Scalar" but this 
            // would have not made for a good name (after macro expansion) for the other 
            // operators (like +,-,*, and /).
            */

            /* The array class must check for the case of self assignment,
            // if A=A then the assignement is skiped (using the logic below).
            // But if a region of A is assigned to another region of A then
            // because the overlap might not be computed correctly (we cannot
            // specify the order of evaluation in the MDI functions).
            */
               if (Array_ID() == Rhs.Array_ID())
                  {
                 // Possible case of A(I+1) = A(I) which would not evaluate correctly 
                 // because of the order of evaluation used in the MDI functions!
     
                    if ( !(isContiguousData() && Rhs.isContiguousData()) )
                       {
                      // Make a copy
                         doubleSerialArray Rhs_Copy = Rhs;

                      // Now just call the operator= again (since Lhs and Rhs have different 
	              // array ids)!
                         *this = Rhs_Copy;
                       }
                      else
                       {
                      // We can skip the assignment of A(I) = A(I) but we have to delete the 
	              // Rhs view!
                         Delete_If_Temporary ( Rhs );
                       }
                  }
                 else
                  {
                 // Bugfix (3/29/95) fixed null array operations between Lhs and Rhs Null 
	         // array objects.  This fix is required for P++ to work properly on 
	         // processors where neither the Lhs of Rhs have an representation on the 
                 // local processor.
                    if (isNullArray() && !isView())
                       {
                      // Bug fix (8/9/94) need to build new descriptor to the correct size 
	              // of the Rhs
                      // APP_ASSERT( Array_Descriptor != NULL );

                      // This is much simpler thant what we have below and it allows the 
	              // bases of the Rhs to be preserved in the Lhs (which was not 
	              // previously true).
                         redim (Rhs);

                      // ... change (8/21/96,kdb) add 8 view pointers ...
	                 POINTER_LIST_INITIALIZATION_MACRO;
                       }

                    APP_ASSERT(isTemporary() == FALSE);

#if EXECUTE_MDI_FUNCTIONS
                    MDI_d_Assign_Array_Equals_Array_Accumulate_To_Operand
                       ( *Lhs_Data_Pointer , *Rhs_Data_Pointer , Mask_Array_Data ,
                         (array_domain*) (&Array_Descriptor.Array_Domain) , 
                         (array_domain*) (&Rhs.Array_Descriptor.Array_Domain) , Mask_Descriptor );
#endif

                 // If A(I) = A(I-1) then the view Rhs was handled by the copy constructor!
                    Delete_If_Temporary ( Rhs );

                 // Now we have to delete the "this" object if it is a View! But we are 
                 // the this object so we have to be very carefull how this is done!
                 // This function will be removed soon to streamline the operator= 
                 // member function
                    APP_ASSERT(isTemporary() == FALSE);
                    Delete_Lhs_If_Temporary ( *this );
                  }
             }
        }

#if COMPILE_DEBUG_STATEMENTS
     Test_Consistency("Test in doubleSerialArray :: operator=");
#endif

  // operator= does the assignment and then returns a doubleSerialArray
     return *this;
   }
\end{lstlisting}


\newpage
\subsection{Parallel Assignment Operator}

   This assignment operator generates the communication, if required, for the P++ statement
being executed.  It calls the PCE function to generate a matching serial array on the current processor
and then calls the serial array assignment operator to do the final lower level work.

\vspace{0.5in}

\begin{lstlisting}{}
doubleArray &
doubleArray :: operator= ( const doubleArray & Rhs )
   {
#if COMPILE_DEBUG_STATEMENTS
  // This is the only test we can do on the input!
     Test_Consistency ("Test Lhs in doubleArray :: operator= (const doubleArray & Rhs)");
     Rhs.Test_Consistency ("Test Rhs in doubleArray :: operator= (const doubleArray & Rhs)");
#endif

     if (Index :: Index_Bounds_Checking)
          Test_Conformability (Rhs);

     doubleSerialArray** Lhs_SerialArray_Pointer = &Array_Descriptor.SerialArray;
     doubleSerialArray** Rhs_SerialArray_Pointer = &(((doubleArray &)Rhs).Array_Descriptor.SerialArray);

  // reorder these tests for better efficiency (can it be improved?)
     bool Case_1 = (getRawDataReferenceCount() == getRawDataReferenceCountBase()) &&
                       !isView() &&
                       Binary_Conformable (Rhs) &&
                       Rhs.isTemporary() &&
                      !Rhs.isView();
  // this case is specific to P++ because temporaries are not condensed in the assignment to the
  // Lhs if that Lhs is a Null Array.  This is an internal difference between A++ and P++.
  // It is done to permit the distribution to be identical for the Lhs instead of being remapped.
  // ... (5/30/98, kdb) this cann't be a null array and a view without problems ...
     bool Case_2 = (getRawDataReferenceCount() == getRawDataReferenceCountBase()) && 
                       Rhs.isTemporary() && isNullArray() && !isView(); 
     if (Case_1 || Case_2)
        {
       // Give back the original Array_Data memory (but only if it exists)!
       // But it should always exist so we don't really have the check!

       // Skip the assignment by stealing the data (delete the Lhs's data if not a NullArray)!

       // Handle the case of assignment to a NULL array (i.e. undimensioned array object
       // or an array object dimensioned to length zero).
          if (isNullArray())
             {
            // Lhs is a Null Array so copy descriptor before assignment!

            // Bug Fix (8/17/94) Null array must have a properly computed array descriptor
            // APP_ASSERT( Array_Descriptor != NULL );
            // Array_Descriptor.ReferenceCountedDelete();
            // delete Array_Descriptor;

            // We can't steal the descriptor because the descriptor contains the Array_ID and it
            // would have to be different for each of the Lhs and Rhs array objects.
            // The Array_ID should be in the array objects.
               Array_Descriptor.Build_Temporary_By_Example ( Rhs.Array_Descriptor ); 
               Array_Descriptor.Array_Domain.Is_A_Temporary = FALSE;
             }
            else
             {
            // Bug fix for nonzero Lhs base -- the Rhs is a temporary and so it has a zero base and the A++
            // assignment is never called so the serial array we will substitute has zero base.  
            // So we have to fix the base of the rhs we will steal and place on the Lhs.
               int temp;
               for (temp=0; temp < MAX_ARRAY_DIMENSION; temp++)
                  {
                    Rhs.Array_Descriptor.SerialArray->Array_Descriptor.Array_Domain.Data_Base[temp] = 
                         Array_Descriptor.SerialArray->Array_Descriptor.Array_Domain.Data_Base[temp];
                    Rhs.Array_Descriptor.SerialArray->Array_Descriptor.Array_Domain.User_Base[temp] = 
                         Array_Descriptor.SerialArray->Array_Descriptor.Array_Domain.User_Base[temp];
                    Rhs.Array_Descriptor.SerialArray->Array_Descriptor.Array_Domain.Scalar_Offset[temp] = 
                         Array_Descriptor.SerialArray->Array_Descriptor.Array_Domain.Scalar_Offset[temp];
                  }
             }

          APP_ASSERT ( getRawDataReferenceCount() == getRawDataReferenceCountBase() );
          APP_ASSERT ( getRawDataReferenceCount() == getRawDataReferenceCountBase() );

          Delete_Array_Data ();
          *Lhs_SerialArray_Pointer = NULL;

          APP_ASSERT(*Lhs_SerialArray_Pointer == NULL);

       // Call the Serial_A++ assignment operator
          *Lhs_SerialArray_Pointer = *Rhs_SerialArray_Pointer;
          APP_ASSERT(*Lhs_SerialArray_Pointer != NULL);
          (*Lhs_SerialArray_Pointer)->Array_Descriptor.Array_Domain.Is_A_Temporary = FALSE;

       // increment the reference count so that after the Rhs is deleted we will still have the
       // serial array around on the Lhs.
          incrementRawDataReferenceCount();
          APP_ASSERT( getRawDataReferenceCount() > getRawDataReferenceCountBase());

       // Bugfix (12/19/94) Force base of SerialArray equal to the value in the P++ descriptor
          APP_ASSERT(Array_Descriptor.SerialArray != NULL);

       // (4/30/97,kdb) Reinitialize the Serial Array_View_Pointers because 
       // SerialArray has been copied from Rhs
	  SERIAL_POINTER_LIST_INITIALIZATION_MACRO;
        }
       else
        {
       // Do the assignment the hard way (not so hard 
       // since we just call the A++ assignment operator)

       // The more complex logic contained in the Serial_A++ implementation can be skipped
       // since we are just calling the Serial_A++ assignment operator and so it is included
       // this means that cases such as A(I) = A(I+1) are properly handled
          APP_ASSERT(Array_Descriptor.SerialArray != NULL);
          APP_ASSERT(Rhs.Array_Descriptor.SerialArray != NULL);

       // We want to allow NULL operations to avoid building new Null arrays for the Lhs
       // So don't allow the Lhs to be rebuilt if the Rhs is a Null array!
          if (isNullArray() && !Rhs.isNullArray())
             {
            // printf ("################################################################## \n");
            // printf ("Case of Lhs being a NULL ARRAY and Rhs is a VIEW -- commented out! \n");
            // printf ("################################################################## \n");
            // The problem here is that the view Lhs is not being build to be the correct size
            // to work well in the parallel environment.  The lhs in this case should be built
            // to be the size of the rhs array data assuming no view.  I.e. the lhs should be
            // the same size as what the rhs is a view of so that the partitioning of the 
            // lhs and the rhs will be alligned (when we get to the serial operator= below).
               bool HANDLE_CASE_OF_VIEW = FALSE;
               if ( Rhs.isView() && HANDLE_CASE_OF_VIEW )
                  {
                 // Force Lhs to be the size of the referenced part of the Rhs
                 // This implies a default partitioning when used with P++.

                    Integer_Array_MAX_ARRAY_DIMENSION_Type Integer_List;
		    int temp;
                    for (temp=0; temp < MAX_ARRAY_DIMENSION; temp++)
                         Integer_List[temp] = Rhs.Array_Descriptor.getLength(temp);

                 // This is NOT EFFICIENT -- but I gather that this case does not happen
                 // sense HANDLE_CASE_OF_VIEW is FALSE!
                    Array_Descriptor = doubleArray_Descriptor_Type (MAX_ARRAY_DIMENSION,Integer_List);

                    Array_Descriptor.display("Exiting in case of null Lhs of operator= ");
                    printf ("Exiting in case of null Lhs of operator= \n");
                    APP_ABORT();
                  }
                 else
                  {
                 // This is just calling the Array_Descriptor_Type's copy constructor so we have to
                 // modify the descriptor in the case it is a view.

                 // If the Rhs is a Null Array then we should never have gotten to this point in the code!
                    APP_ASSERT( Rhs.isNullArray() == FALSE );

                 // This copies the domain in Rhs into the domain in the Lhs except that
                 // subsequently the bases are set to the default A++/P++ base (typically zero).
                    Array_Descriptor.Build_Temporary_By_Example ( Rhs.Array_Descriptor );

                 // ... change (10/29/96,kdb) set bases to Rhs bases because 
                 // Build_Temporary_By_Example sets the bases to zero 
                 // after copying Rhs and in the case of a null Lhs we now 
                 // want the bases of Lhs and Rhs to be the same ...

                 // ... set bases to Rhs bases ...
                 // Now we reset the base to be that of the Rhs (perhaps we should have just copied the
                 // domain explicitly -- since we copied the Rhs domain reset the base and then set the
                 // base again).
	            int nd = 0; 
                    for (nd=0;nd<MAX_ARRAY_DIMENSION;nd++)
		         setBase(Rhs.Array_Descriptor.getRawBase(nd),nd);

                    setTemporary(FALSE);

                    if (Array_Descriptor.Array_Domain.Array_Conformability_Info != NULL)
                       {
                         APP_ASSERT (Array_Descriptor.Array_Domain.Array_Conformability_Info->getReferenceCount() >= 
                                     Array_Conformability_Info_Type :: getReferenceCountBase());
                         Array_Descriptor.Array_Domain.Array_Conformability_Info->decrementReferenceCount();
                         if (Array_Descriptor.Array_Domain.Array_Conformability_Info->getReferenceCount()
                              < Array_Conformability_Info_Type :: getReferenceCountBase())
                            {
                              delete Array_Descriptor.Array_Domain.Array_Conformability_Info;
                            }
                         Array_Descriptor.Array_Domain.Array_Conformability_Info = NULL;
                       }

                    APP_ASSERT( Array_Descriptor.Array_Domain.Array_Conformability_Info == NULL );
                  }

               if (HANDLE_CASE_OF_VIEW)
                  {
                    APP_ASSERT( isView() == FALSE );
                  }

            // Now allocate the data for the Lhs (so we can copy the Rhs into the Lhs)
               Allocate_Array_Data(TRUE);
             }

          APP_ASSERT(isTemporary() == FALSE);
          APP_ASSERT(Array_Descriptor.SerialArray != NULL);
          APP_ASSERT(Array_Descriptor.SerialArray->isTemporary() == FALSE);

       // Figure out the parallel communication required and form the conformable 
       // views of the SerialArray objects then call the SerialArray assignment 
       // operator.

          doubleSerialArray  *This_SerialArray = NULL;
          doubleSerialArray  *Rhs_SerialArray  = NULL;
	  intSerialArray *Mask_SerialArray     = NULL;
	  intSerialArray *Old_Mask_SerialArray = NULL;

          Array_Conformability_Info_Type *Array_Set = NULL;
          if (Where_Statement_Support :: Where_Statement_Mask == NULL)
             {
               if ((usesIndirectAddressing() == TRUE) || (Rhs.usesIndirectAddressing() == TRUE))
                  {
                    Array_Set = doubleArray :: Parallel_Indirect_Conformability_Enforcement ( *this, This_SerialArray, Rhs, Rhs_SerialArray );
                  }
                 else
                  {
                    Array_Set = doubleArray :: Parallel_Conformability_Enforcement ( *this, This_SerialArray, Rhs, Rhs_SerialArray );
                  }
             }
            else
             {
            // ... (4/10/97, kdb) save old serial where mask because
            // Serial_Where_Statement_Mask has to be temporarily 
            // reset to make where work ...
               Old_Mask_SerialArray = Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray;

               if ((usesIndirectAddressing() == TRUE) || (Rhs.usesIndirectAddressing() == TRUE))
                  {
                    printf ("Sorry, not implemented: can't mix indirect addressing (case of where and 2 array objects).\n");
                    APP_ABORT();
                  }
                 else
                  {
                    Array_Set = doubleArray :: Parallel_Conformability_Enforcement
                         (*this, This_SerialArray, *Where_Statement_Support :: Where_Statement_Mask, Mask_SerialArray, Rhs, Rhs_SerialArray );
                  }

            // ...  this will be reset later ...
               Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray = Mask_SerialArray; 
             }

          if (Array_Set == NULL)
               Array_Set = new Array_Conformability_Info_Type();

          APP_ASSERT(Array_Set        != NULL);
          APP_ASSERT(This_SerialArray != NULL);
          APP_ASSERT(Rhs_SerialArray  != NULL);

       // Call the A++ assignment operator!
          *This_SerialArray = *Rhs_SerialArray;

       // Replace the where mask
	  if (Where_Statement_Support :: Where_Statement_Mask != NULL)
               Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray = Old_Mask_SerialArray;

#if defined(PPP) && defined(USE_PADRE)
       // We have to remove the references in PADRE to the Serial_Array object
       // which is being deleted.  This is a consequence of P++ using PADRE in a way
       // so as to prevent the redundent storage of Array_Domain objects
       // (specifically we use PADRE in a way so that only references are stored).
          setLocalDomainInPADRE_Descriptor(NULL);
          Rhs.setLocalDomainInPADRE_Descriptor(NULL);
#endif

          This_SerialArray->decrementReferenceCount();
          if (This_SerialArray->getReferenceCount() < doubleArray :: getReferenceCountBase())
               delete This_SerialArray;

       // (12/09/2000) Check for reuse of serialArray object in return value (do not delete it if it was reused)
          if (Rhs_SerialArray->isTemporary() == FALSE)
             {
               Rhs_SerialArray->decrementReferenceCount();
               if (Rhs_SerialArray->getReferenceCount() < doubleArray :: getReferenceCountBase())
                    delete Rhs_SerialArray;
             }

	  if (Mask_SerialArray != NULL) 
             {
#if defined(PPP) && defined(USE_PADRE)
               Where_Statement_Support :: Where_Statement_Mask->setLocalDomainInPADRE_Descriptor(NULL);
#endif
               Mask_SerialArray->decrementReferenceCount();
               if (Mask_SerialArray->getReferenceCount() < intArray :: getReferenceCountBase())
                    delete Mask_SerialArray;
             }

       // Now set these pointers to NULL since we don't use them any more
          This_SerialArray = NULL;
          Rhs_SerialArray  = NULL;
	  Mask_SerialArray = NULL;

       // Now we need to do the required message passing to fixup the "this" array
       // first check to see if just updating the ghost boundaries is enough
          if (Communication_Manager :: Number_Of_Processors > 1)
             {
            // All ghost boundaries updated together (not seperate treatment for each edge)
               if (Array_Set != NULL)
	          {
                    if (Array_Set->Full_VSG_Update_Required == FALSE)
                       {
                         int update_any = FALSE;
                         int i;
                         for (i=0; i < MAX_ARRAY_DIMENSION; i++)
                            {
                              if ((Array_Set->Update_Left_Ghost_Boundary_Width [i] > 0) || 
		                  (Array_Set->Update_Right_Ghost_Boundary_Width[i] > 0)) 
	                           update_any = TRUE;		 
                            }

                         if (update_any)
                            {
#if COMPILE_DEBUG_STATEMENTS
                              if (APP_DEBUG > 0)
                                   printf ("UPDATING GHOST BOUNDARIES (Overlap Update)! \n");

                           // error checking
                              for (i=0; i < MAX_ARRAY_DIMENSION; i++)
                                 {
                                   if ((Array_Set->Update_Left_Ghost_Boundary_Width[i] > 0) || 
                                       (Array_Set->Update_Right_Ghost_Boundary_Width[i] > 0))
                                      {
                                        if (Array_Descriptor.Array_Domain.InternalGhostCellWidth[i] == 0)
                                           {
                                             printf ("ERROR: No ghost cells along axis %d to ",i);
                                             printf ("support message passing ");
                                             printf ("(Full_VSG_Update_Required should be TRUE ");
                                             printf ("but it is FALSE) \n");
                                             APP_ABORT();
                                           }
                                      }

                                // If we are the leftmost processor then it is an error to 
                                // pass boundary info the the left
                                   if (Array_Descriptor.isLeftPartition(i))
                                      {
                                        if (Array_Set->Update_Left_Ghost_Boundary_Width[i] != 0)
                                           {
                                             printf ("ERROR: Left side -- Axis i = %d \n",i);
                                             Array_Set->display("ERROR: Left processor should not pass left -- Array_Set->Update_Left_Ghost_Boundary_Width[i] == 0");
                                             view ("ERROR: Left processor should not pass left -- Array_Set->Update_Left_Ghost_Boundary_Width[i] == 0");
                                           }
                                        APP_ASSERT (Array_Set->Update_Left_Ghost_Boundary_Width[i] == 0);
                                      }

                                // If we are the rightmost processor then it is an error to 
                                // pass boundary info the the right
                                   if (Array_Descriptor.isRightPartition(i))
                                      {
                                        if (Array_Set->Update_Right_Ghost_Boundary_Width[i] != 0)
                                           {
                                             printf ("ERROR: Right side -- Axis i = %d \n",i);
                                             Array_Set->display("ERROR: Right processor should not pass right -- Array_Set->Update_Right_Ghost_Boundary_Width[i] == 0");
                                             view ("ERROR: Right processor should not pass right -- Array_Set->Update_Right_Ghost_Boundary_Width[i] == 0");
                                           }
                                        APP_ASSERT (Array_Set->Update_Right_Ghost_Boundary_Width[i] == 0);
                                      }
                                 }
#endif
                           // For now we update all ghost boundaries but later we can be 
                           // more efficient and selective
                           /*
                           // ... (12/11/96,kdb) now only the necessary ghost cells
                           // are updated.  The updateGhostBoundaries code needs
                           // Array_Set to do this.  To avoid passing in an
                           // extra parameter, temporarily attach this to
                           // Array_Descriptor since the Array_Conformability_Info
                           // will be deleted anyways right after this. ...
                           */
                              if (Array_Descriptor.Array_Domain.Array_Conformability_Info != NULL)
                                 {
                                   Array_Descriptor.Array_Domain.Array_Conformability_Info->decrementReferenceCount();
                                   if (Array_Descriptor.Array_Domain.Array_Conformability_Info->getReferenceCount() < 
                                       intArray :: getReferenceCountBase())
                                        delete Array_Descriptor.Array_Domain.Array_Conformability_Info;
                                 }

                           // ... don't need reference counting ...
                              Array_Descriptor.Array_Domain.Array_Conformability_Info = Array_Set;
                              updateGhostBoundaries();
                              Array_Descriptor.Array_Domain.Array_Conformability_Info = NULL;
                            }
                           else
                            {
                           // No updates specified
                            }
                       }
                      else
                       {
                      // Full_VSG_Update_Required == TRUE

                      // Since the Regular Section transfer used in PARTI does not update
                      // the ghost boundaries we have to force the update here!
                         updateGhostBoundaries();
                       }
                  }
                 else
                  {
                 // Array_Set is null because indirect addressing was used. 
                 // Update ghost boundaries.
                    updateGhostBoundaries();
                  }
             } // end of (Communication_Manager :: Number_Of_Processors > 1)

       // Need to delete the Array_Set to avoid a memory leak
       // Array_Set can be null now if indirect addressing
       // APP_ASSERT (Array_Set != NULL);
          if (Array_Set != NULL);
	     {
               APP_ASSERT (Array_Set->getReferenceCount() >= Array_Conformability_Info_Type :: getReferenceCountBase());
               Array_Set->decrementReferenceCount();
               if (Array_Set->getReferenceCount() < Array_Conformability_Info_Type :: getReferenceCountBase())
                    delete Array_Set;
               Array_Set = NULL;
	     }
        }

#if COMPILE_DEBUG_STATEMENTS
     APP_ASSERT(Array_Descriptor.Array_Domain.Is_A_Temporary == FALSE);
     Test_Consistency("Test (on return) in doubleArray :: operator= (const doubleArray & Rhs)");
#endif

  // Manage temporary if it appears on the Rhs or Lhs
     Delete_If_Temporary ( Rhs );
     Delete_Lhs_If_Temporary ( *this );

     if (Array_Descriptor.Array_Domain.Array_Conformability_Info != NULL)
        {
          Array_Descriptor.Array_Domain.Array_Conformability_Info->decrementReferenceCount();
          if (Array_Descriptor.Array_Domain.Array_Conformability_Info->getReferenceCount() <
              Array_Conformability_Info_Type :: getReferenceCountBase())
               delete Array_Descriptor.Array_Domain.Array_Conformability_Info;
          Array_Descriptor.Array_Domain.Array_Conformability_Info = NULL;
        }

     return *this;
   }
\end{lstlisting}

\newpage
\section{Parallel Abstract Operator Support}

 This function is used by all of the binary operator that are communative
(another similar function is called for all non-commutative operators).
The principle difference being in the handling of how temporaries are reused
(communative operators allowing greater flexability in the reuse of temporaries).

   The purpose of this operator is to take the different pieces of a parallel array
(the pieces built by different binary operators) and assemble them into a parallel array.

\vspace{0.5in}

\begin{lstlisting}{}

// ************************************************************************
// usual binary operators: operator+ operator- operator* operator/ operator% 
// for array to array operations
// ************************************************************************
doubleArray &
doubleArray :: Abstract_Operator (
     Array_Conformability_Info_Type *Array_Set, 
     const doubleArray & Lhs_ParallelArray, const doubleArray & Rhs_ParallelArray, 
     doubleSerialArray* Lhs_Serial_PCE_Array, doubleSerialArray* Rhs_Serial_PCE_Array, 
     doubleSerialArray & X_SerialArray )
   {
  // error checking
     APP_ASSERT(Array_Set != NULL);

#if COMPILE_DEBUG_STATEMENTS
  // These are the only tests we can do on the input!
     Array_Set->Test_Consistency("Test Array_Set in #4 doubleArray :: Abstract_Operator(Array_Conformability_Info_Type,doubleArray,doubleArray,doubleSerialArray)");
     Lhs_ParallelArray.Test_Consistency ("Test LHS in #4 doubleArray :: Abstract_Operator(Array_Conformability_Info_Type,doubleArray,doubleArray,doubleSerialArray)");
     Rhs_ParallelArray.Test_Consistency ("Test RHS in #4 doubleArray :: Abstract_Operator(Array_Conformability_Info_Type,doubleArray,doubleArray,doubleSerialArray)");
     X_SerialArray.Test_Consistency     ("Test X_SerialArray in #4 doubleArray :: Abstract_Operator(Array_Conformability_Info_Type,doubleArray,doubleArray,doubleSerialArray)");
#endif

     if (Index :: Index_Bounds_Checking)
          Lhs_ParallelArray.Test_Conformability (Rhs_ParallelArray);

  // The size of the temporary must be the same as that of the Lhs (Lhs based owners compute rule)
     doubleSerialArray *Data = &((doubleSerialArray &) X_SerialArray);
     APP_ASSERT(Data != NULL);

     doubleArray* Temporary = NULL;
     Memory_Source_Type Result_Is_Lhs_Or_Rhs_Or_New_Memory = Uninitialized_Source;
     if ( Lhs_ParallelArray.isTemporary() == TRUE )
        {
       // Temporary reuse of serial array already handled at Serial_A++ level
          Temporary = &((doubleArray &) Lhs_ParallelArray);
          Result_Is_Lhs_Or_Rhs_Or_New_Memory = Memory_From_Lhs;

       // Delete the old Array_Conformability_Info object so that the new one can be inserted
          if (Lhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info != NULL)
             {
               Lhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info->decrementReferenceCount();
               if (Lhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info->getReferenceCount() < 
                   Array_Conformability_Info_Type :: getReferenceCountBase())
                    delete Lhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info;
             }

#if COMPILE_DEBUG_STATEMENTS
          Array_Set->Test_Consistency("Test Array_Set in #4 doubleArray :: Abstract_Operator (after delete Lhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info)");
#endif
          ((doubleArray&)Lhs_ParallelArray).Array_Descriptor.Array_Domain.Array_Conformability_Info = Array_Set;
       // Bugfix (11/27/2000)
          Array_Set->incrementReferenceCount();

#if COMPILE_DEBUG_STATEMENTS
          Array_Set->Test_Consistency("Lhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info == Array_Set at MIPOINT of #4 doubleArray :: Abstract_Operator(Array_Conformability_Info_Type,doubleArray,doubleArray,doubleSerialArray)");
#endif

          Array_Domain_Type :: fixupLocalBase 
	     ( (Array_Domain_Type&)Lhs_ParallelArray.Array_Descriptor.Array_Domain , 
	       Data->Array_Descriptor.Array_Domain , 
               Lhs_ParallelArray.Array_Descriptor.Array_Domain , 
               Lhs_ParallelArray.Array_Descriptor.SerialArray->
	       Array_Descriptor.Array_Domain );

          APP_ASSERT (Temporary != NULL);
          APP_ASSERT (Temporary->Array_Descriptor.SerialArray != NULL);
          APP_ASSERT (Temporary->Array_Descriptor.SerialArray->getReferenceCount() >= doubleArray :: getReferenceCountBase());
       // Delete the serial array in the Temporary that will be reused 
       // (so it can be replaced by the input serialArray!)
          Temporary->Array_Descriptor.SerialArray->decrementReferenceCount();
          if (Temporary->Array_Descriptor.SerialArray->getReferenceCount() < doubleArray :: getReferenceCountBase())
               delete Temporary->Array_Descriptor.SerialArray;

       // Copy the input serialArray into the temporary (the return value)
          Temporary->Array_Descriptor.SerialArray = Data;


          APP_ASSERT (Data->getRawDataReferenceCount() >= getRawDataReferenceCountBase());
        }
       else
        {
       // In the case of a Full_VSG_Update only the Lhs can be reused the Rhs may not be reused
       // This is because the Rhs is reconstructed for each binary operation and the data for the
       // Rhs is assembled into the newly constructed Rhs (which is the size of the local Lhs)
       // from all the processors owning that part of the global indexspace required.
       // This detail was unexpected and might be handled more efficiently in the future.
          if ( (Rhs_ParallelArray.Array_Descriptor.Array_Domain.Is_A_Temporary == TRUE) && 
               (Array_Set->Full_VSG_Update_Required == FALSE) )
             {
            // Temporary reuse of serial array already handled at Serial_A++ level
               Temporary = &((doubleArray &) Rhs_ParallelArray);
               Result_Is_Lhs_Or_Rhs_Or_New_Memory = Memory_From_Rhs;

               if (Rhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info != NULL)
                  {
                    Rhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info->decrementReferenceCount();
                    if (Rhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info->getReferenceCount() < 
                        Array_Conformability_Info_Type :: getReferenceCountBase())
                         delete Rhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info;
                  }

#if COMPILE_DEBUG_STATEMENTS
               Array_Set->Test_Consistency("Test Array_Set in #4 doubleArray :: Abstract_Operator (after delete Rhs_ParallelArray.Array_Descriptor.Array_Domain.Array_Conformability_Info)");
#endif

               ((doubleArray&)Rhs_ParallelArray).Array_Descriptor.Array_Domain.Array_Conformability_Info = Array_Set;
            // Bugfix (11/27/2000)
               Array_Set->incrementReferenceCount();

               Array_Domain_Type :: fixupLocalBase 
		  ((Array_Domain_Type&)Rhs_ParallelArray.Array_Descriptor.Array_Domain , 
		   Data->Array_Descriptor.Array_Domain , 
                   Rhs_ParallelArray.Array_Descriptor.Array_Domain , 
                   Rhs_ParallelArray.Array_Descriptor.SerialArray->
		   Array_Descriptor.Array_Domain );

            // ... temporary is consistent with Rhs so reverse offsets ...
               bool reverse_offset = TRUE;

               Array_Domain_Type ::  Fix_Array_Conformability 
		  ( *Array_Set, Rhs_ParallelArray.Array_Descriptor.Array_Domain , 
		     Data->Array_Descriptor.Array_Domain, reverse_offset );

               APP_ASSERT (Data->getRawDataReferenceCount() >= getRawDataReferenceCountBase());
             }
            else
             {
            // No temporary to reuse so we have to build one!

            // We should better call the doubleArray_Descriptor_Type :: Build_Temporary_By_Example
            // Now we have a descriptor based on the descriptor from the Lhs operand.  But we
            // have to fix it up in order to use it. Or mabe we should change the design so 
            // we don't have to change it (i.e. no re-centering would then be required) 

            // This is more efficient than the previous version which build a descriptor and
            // then forced 2 copies of the descriptor before ending up with a temporary to use.
               bool AvoidBuildingIndirectAddressingView = TRUE;
               Temporary = new doubleArray ( Data ,
                                         &(Lhs_ParallelArray.Array_Descriptor.Array_Domain),
                                         AvoidBuildingIndirectAddressingView );

            // The base now needs to be reset since temporaries always have APP_Global_Array_Base as a base
	    // ... only reset if no indirect addressing ...
	       if (!Temporary->Array_Descriptor.Array_Domain.Uses_Indirect_Addressing)
                    Temporary->setBase(APP_Global_Array_Base);

               Temporary->setTemporary(TRUE);

            // This is now we acumulate the information used to determine message passing
            // when the operator= is executed!
               APP_ASSERT (Temporary->Array_Descriptor.Array_Domain.Array_Conformability_Info == NULL);
               Temporary->Array_Descriptor.Array_Domain.Array_Conformability_Info = Array_Set;
            // Bugfix (11/27/2000)
               Array_Set->incrementReferenceCount();

            // ... temporary is consistent with Lhs so don't reverse offsets ...
               bool reverse_offset = FALSE;

               Array_Domain_Type ::  Fix_Array_Conformability ( 
		    *Array_Set, Temporary->Array_Descriptor.Array_Domain , 
		    Data->Array_Descriptor.Array_Domain, reverse_offset);

            // Bugfix (9/14/95) This should fix the problem related to the Rhs being a temporary
            // and thus the Rhs serial array being reused in the A++ class libaray such that it
            // is referenced in the Temporary which the function returns and the Rhs.
            // The problem shows up when B is a null array and we have B = B + B * B;
            // I would guess that this is because the Null arrays objects in this case
            // are multibily referenced rather than redundently built.
            // But if so --- is this the best place to increment the reference count!
               APP_ASSERT ( Data != NULL );
               if ( (Rhs_ParallelArray.isTemporary() == TRUE) && (Data->isNullArray() == TRUE) )
                  {
                    Data->incrementReferenceCount();
                  }

               Result_Is_Lhs_Or_Rhs_Or_New_Memory = Newly_Allocated_Memory;
             }
        }

     APP_ASSERT(Temporary != NULL);
     APP_ASSERT(Temporary->Array_Descriptor.Array_Domain.Array_Conformability_Info != NULL);
     APP_ASSERT(Temporary->Array_Descriptor.SerialArray != NULL);

     APP_ASSERT(Temporary->Array_Descriptor.Array_Domain.Is_A_Temporary == TRUE);

  // If the Lhs was a temporary then we used it so we don't have to call
  // the "Delete_If_Temporary ( Lhs_ParallelArray );" function for the LHS
  // We want to delete the RHS if it is a temporary unless we used it
     if (Result_Is_Lhs_Or_Rhs_Or_New_Memory != Memory_From_Rhs)
          Delete_If_Temporary ( Rhs_ParallelArray );

#if COMPILE_DEBUG_STATEMENTS
     APP_ASSERT(Temporary->Array_Descriptor.Array_Domain.Is_A_Temporary == TRUE);
     Temporary->Test_Consistency ("Test TEMPORARY at BASE of #4 doubleArray :: Abstract_Operator(Array_Conformability_Info_Type,doubleArray,doubleArray,doubleSerialArray)");
#endif

     return *Temporary;
   }
\end{lstlisting}

\newpage
\section{Serial Abstract Operator Support}

   This abstract operator is mostly supportive of memory management (temporary management).
The details of the abstract operators for A++ and P++ are sufficently different that there
are separate implementations.  This is one of the few places in A++/P++ where the A++ and P++
code are not the same code using preprocessor macros to define the conditional compilation.

\vspace{0.5in}

\begin{lstlisting}{}

doubleSerialArray &
doubleSerialArray :: Abstract_Binary_Operator ( const doubleSerialArray & Lhs , const doubleSerialArray & Rhs ,
   MDI_double_Prototype_2 Operation_Array_Data ,
   MDI_double_Prototype_3 Operation_Array_Data_Accumulate_To_Existing_Operand ,
   int Operation_Type )
   { 
#if COMPILE_DEBUG_STATEMENTS
     Lhs.Test_Consistency("Test of Lhs in #3 doubleSerialArray :: Abstract_Binary_Operator");
     Rhs.Test_Consistency("Test of Rhs in #3 doubleSerialArray :: Abstract_Binary_Operator");
#endif
 
  // Are the arrays the same size (otherwise issue error message and stop).
     if (Index :: Index_Bounds_Checking)
          Lhs.Test_Conformability (Rhs);

     Memory_Source_Type Result_Is_Lhs_Or_Rhs_Or_New_Memory = Uninitialized_Source;

     doubleSerialArray & Temporary_Array = 
          Build_New_Array_Or_Reuse_Operand ( Lhs , Rhs , Result_Is_Lhs_Or_Rhs_Or_New_Memory );

#if COMPILE_DEBUG_STATEMENTS
     Temporary_Array.Test_Consistency("Test of Temporary_Array in #3 doubleSerialArray :: Abstract_Binary_Operator");
#endif

     if (Expression_Tree_Node_Type :: DEFER_EXPRESSION_EVALUATION)
        {
          if (Result_Is_Lhs_Or_Rhs_Or_New_Memory == NEWLY_ALLOCATED_MEMORY) 
             {
               Temporary_Array.Add_Defered_Expression ( new doubleSerialArray_Function_2 ( Operation_Type , Operation_Array_Data , Temporary_Array , Lhs , Rhs ) );
             }
	  else
             {
               if (Result_Is_Lhs_Or_Rhs_Or_New_Memory == MEMORY_FROM_LHS) 
                  {
                    Temporary_Array.Add_Defered_Expression ( new doubleSerialArray_Function_3 ( Operation_Type , Operation_Array_Data_Accumulate_To_Existing_Operand , Lhs , Rhs ) );
                  }
                 else
                  {
                    APP_ASSERT(Result_Is_Lhs_Or_Rhs_Or_New_Memory == MEMORY_FROM_RHS); 
                    Temporary_Array.Add_Defered_Expression ( new doubleSerialArray_Function_3 ( Operation_Type , Operation_Array_Data_Accumulate_To_Existing_Operand , Rhs , Lhs ) );
                  }
             }
        }
     else
        {
          /* Notice that we assume that the mask might be a view! */
          int* Mask_Array_Data = NULL;
          array_domain* Mask_Descriptor = NULL;

          if (Where_Statement_Support :: Where_Statement_Mask != NULL)
             {
#if defined(SERIAL_APP)
            // error checking
            APP_ASSERT(Where_Statement_Support :: Serial_Where_Statement_Mask == NULL);

            // The serial array class does not have access to the data (this is a 
	    // permission problem I have to fix) 
               Mask_Array_Data = Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray->getDataPointer();
               Mask_Descriptor = (array_domain*) Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray->getDomainPointer();
            // Are the arrays the same size (otherwise issue error message and stop).
               if (Index :: Index_Bounds_Checking)
                    Lhs.Test_Conformability (*Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.SerialArray);
#else
               Mask_Array_Data = Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.Array_Data;
               Mask_Descriptor = (array_domain*) &(Where_Statement_Support :: Where_Statement_Mask->Array_Descriptor.Array_Domain);
            // Are the arrays the same size (otherwise issue error message and stop).
               if (Index :: Index_Bounds_Checking)
                    Lhs.Test_Conformability (*Where_Statement_Support :: Where_Statement_Mask);
#endif
             }
#if defined(SERIAL_APP)
	     else if (Where_Statement_Support :: Serial_Where_Statement_Mask != NULL)
	     {
               Mask_Array_Data = Where_Statement_Support :: 
		  Serial_Where_Statement_Mask->Array_Descriptor.Array_Data;
               Mask_Descriptor = (array_domain*)(&Where_Statement_Support :: 
		  Serial_Where_Statement_Mask->Array_Descriptor.Array_Domain);
               // Are the arrays the same size (otherwise issue error message and 
	       // stop).
               if (Index :: Index_Bounds_Checking)
                  Lhs.Test_Conformability 
		     (*Where_Statement_Support :: Serial_Where_Statement_Mask);
	     }
#endif

          if (Result_Is_Lhs_Or_Rhs_Or_New_Memory == NEWLY_ALLOCATED_MEMORY) 
             {
#if EXECUTE_MDI_FUNCTIONS
               (*Operation_Array_Data) 
		  (Temporary_Array.Array_Descriptor.Array_Data , Lhs.Array_Descriptor.Array_Data , Rhs.Array_Descriptor.Array_Data , 
		   Mask_Array_Data , 
		   (array_domain*) (&Temporary_Array.Array_Descriptor.Array_Domain) , 
		   (array_domain*) (&Lhs.Array_Descriptor.Array_Domain) ,
                   (array_domain*) (&Rhs.Array_Descriptor.Array_Domain) , Mask_Descriptor );
#endif
            // If we had to build the temporary using NEWLY_ALLOCATED_MEMORY then neither of the
            // input arrays where a temporary (which could be reused) -- so we don't have to
            // delete if temporary since we know that neither could be.  So the following
            // function calls can be eliminated.
               Delete_If_Temporary ( Lhs );
               Delete_If_Temporary ( Rhs );
             }
            else
             {
            // We use the same functions below but change the order 
            // of the Lhs and Rhs in the parameter list (and the order of the Base,Bound,etc)!
            // BUG FIX: (The first subtle error was that the Base,Bound,etc order was not swaped)
            // However we will leave the interface to the Machine_Dependent_Interface functions
            // such that these related functions are implemented once since we want to
            // limit the number of machine dependent functions (this enhances the portability).
               if (Result_Is_Lhs_Or_Rhs_Or_New_Memory == MEMORY_FROM_LHS) 
                  {
#if EXECUTE_MDI_FUNCTIONS
                    (*Operation_Array_Data_Accumulate_To_Existing_Operand) (
                     Lhs.Array_Descriptor.Array_Data , Rhs.Array_Descriptor.Array_Data , Mask_Array_Data ,
                     (array_domain*) (&Lhs.Array_Descriptor.Array_Domain) , 
		     (array_domain*) (&Rhs.Array_Descriptor.Array_Domain) , 
		     Mask_Descriptor );
#endif

                    Delete_If_Temporary ( Rhs );

                 // Bugfix (12/3/2000) we have to delete the Temporary in the abstract operator (to be consistent)
                    Delete_If_Temporary ( Lhs );
                  }
	       else
                  {
                    APP_ASSERT(Result_Is_Lhs_Or_Rhs_Or_New_Memory == MEMORY_FROM_RHS);
#if EXECUTE_MDI_FUNCTIONS
                    (*Operation_Array_Data_Accumulate_To_Existing_Operand) (
                      Rhs.Array_Descriptor.Array_Data , Lhs.Array_Descriptor.Array_Data , Mask_Array_Data ,
                      (array_domain*) (&Rhs.Array_Descriptor.Array_Domain) , 
		      (array_domain*) (&Lhs.Array_Descriptor.Array_Domain) , Mask_Descriptor );
#endif

                 // Since we got the temporary from the Rhs the rule is that we first looked
                 // at the Lhs (and took it if it was a temporary) -- so the Lhs is NOT a 
                 // temporary.  So we can eliminate the function call to delete the Lhs.
                    Delete_If_Temporary ( Lhs );

                 // Bugfix (12/3/2000) we have to delete the Temporary in the abstract operator (to be consistent)
                    Delete_If_Temporary ( Rhs );
                  }
             }
        }

#if COMPILE_DEBUG_STATEMENTS
     Temporary_Array.Test_Consistency("Test in #3 doubleSerialArray :: Abstract_Binary_Operator");
#endif

     return Temporary_Array;
   }

\end{lstlisting}



\newpage
\section{Example Makefiles for A++/P++}

   Compiling P++ is only a little more trouble than compiling A++, additional include paths and
library paths are required for MPI.  The example Makefile is automatically generated within the
A++P++/P++/EXAMPLES directory to serve as a guide to building makefile specific to P++ applications.

   Shown below is an example for the SUN, automatically generated in the compile tree for the target
architecture.  The final step of the installation process (makes ``make install'' rule) tests
the use of the current installation by recompiling (and executing) one of the example programs.

\vspace{0.5in}

Below is the Makefile.user.defs file (included in the Makefile.user makefile).  this file contains
the machine specific aspects of how to build P++ applications.  Similar files are build for A++ in
the A++P++/A++/EXAMPLES directory, but they are much simplier.  Most people don't require the A++
versions as a guide as much as they do often require the P++ specific details which are more
complex.

\begin{lstlisting}{}

top_srcdir              = /home/dquinlan/A++P++/A++P++Source/A++P++/P++
srcdir                  = /home/dquinlan/A++P++/A++P++Source/A++P++/P++/EXAMPLES
top_builddir            = ..
CPPFLAGS                = -I/usr/local/mpi/mpich-1.1.1/include -I/usr/local/mpi/mpich-1.1.1/lib/solaris/ch_p4 
CC                      = cc
C_OPTIONS               = 
CXX                     = CC
CXX_DEBUG               = -g
CXX_OPT                 = 
CXX_OPTIONS             = 
CXX_DL_COMPILE_FLAGS    = -PIC
C_DEBUG                 = -g
C_OPT                   = 
C_DL_COMPILE_FLAGS      = -KPIC
MPIINCLUDE              = -I/usr/local/mpi/mpich-1.1.1/include -I/usr/local/mpi/mpich-1.1.1/lib/solaris/ch_p4
MPILIBDIRS              = -L/usr/local/mpi/mpich-1.1.1/lib/solaris/ch_p4
MPILIBS                 =  -lpmpich -lmpich -lsocket -lnsl -lpthread -lnsl -laio -lc
INCLUDES                = -I. -I${srcdir} -I${top_builddir} -I${top_srcdir}/include -I/usr/local/mpi/mpich-1.1.1/include -I/usr/local/mpi/mpich-1.1.1/lib/solaris/ch_p4  -I/home/dquinlan/A++P++/A++P++Source/A++P++/P++/STL-link -I$(top_srcdir)/PADRE/IndirectAddressing -I$(top_builddir)/PADRE/IndirectAddressing -I$(top_srcdir)/PARTI -I$(top_builddir)/PARTI
DEFS                    = 
CXXLD                   = CC
CCLD                    = $(CC)
CXXFLAGS                =  $(CXX_DEBUG) $(CXX_DEFINES) $(CXX_OPTIONS) $(CXX_WARNINGS) $(CXX_OPT)
CFLAGS                  =  $(C_DEBUG) $(C_OPTIONS) $(C_OPT) $(C_WARNINGS) $(C_DL_COMPILE_FLAGS)
LDFLAGS                 = 
LIBS                    =  -lc -L/usr/local/mpi/mpich-1.1.1/lib/solaris/ch_p4  -lpmpich -lmpich -lsocket -lnsl -lpthread -lnsl -laio -lc -L$(top_builddir)/src -lPpp -lPpp_static -lPpp  -L/usr/local/mpi/mpich-1.1.1/lib/solaris/ch_p4  -lpmpich -lmpich -lsocket -lnsl -lpthread -lnsl -laio -lc -lc -lpthread -lm
LDADD                   = $(PPP_PATH_TO_SHARED_LIB) $(PXX_RPATH)
PPP_PATH_TO_SHARED_LIB  = -L$(top_srcdir)/lib/lib
PXX_RPATH               = -R /home/dquinlan2/A++P++/SUN_CC_NOPADRE_INDIRECT_ADDRESSING/P++/src


CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)

LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) $(LDADD) -o $@

\end{lstlisting}

\vspace{0.5in}

Below is the Makefile.user file (and makefile called with ``make -f makefile.user $<$your-program$>$''):

\begin{lstlisting}{}

#
# This is a simple makefile that users can use to compile P++
# applications.  Fill in the name of your application,
# the object files it depends upon and any dependencies.
# You may fill in the USER_... variables here or add the
# definitions on the command line, i.e.
#   make -f Makfile.user USER_APPLICATION=test_Ppp_execution USER_APPLICATION_OBJECTS=test_Ppp_execution.o
#
USER_APPLICATION =
USER_APPLICATION_OBJECTS =
USER_APPLICATION_DEPENDENCIES =
USER_LIBS =


# This compiles the application.  This is the default action
# because it appears before all other explicit rules.
compile: $(USER_APPLICATION)


# This runs the user application.
# The generalized-parallel-run script is used to make the command portable.
# All it does is decide on what command should be issued to run the parallel
# program.  For your information, the commands are shown before being
# executed.
# See the script to see the decision is made.  Type generalized-parallel-run
# to get the help message.
run: $(USER_APPLICATION)
        @echo running $(USER_APPLICATION) with 2,3 processors.
        sh ../generalized-parallel-run 2,3 $(USER_APPLICATION)


# This cleans up intermediate files.
clean:
        rm -f $(USERAPPLICATION) $(USER_APPLICATION_OBJECTS)


# Makefile.user.defs defines all the makefile variable to be compatible
# with the way the library was configured.  Feel free to look at it.
# It is meant to be eye-friendly.
include Makefile.user.defs


# This defines the sufficces make cares about.
.SUFFIXES:.o .C

.C.o:
        $(CXXCOMPILE) -c $<

$(USER_APPLICATION): $(USER_APPLICATION_DEPENDENCIES) $(USER_APPLICATION_OBJECTS)
        $(CXXLINK) $(USER_APPLICATION_OBJECTS) $(LIBS) $(USER_LIBS)

\end{lstlisting}

\end{document}






