package mops;
// $Id: Ast.java,v 1.1 2006/09/08 11:39:23 dquinlan Exp $

import java.io.*;
import java.util.*;

/**
 * AST: Abstract Syntax Tree
 */
class Ast
{
  public Ast()
  {
    setKind(-1);
    setAddress(0);
    setChildren(null);
  }

  public void setKind(int kind)
  {
    this.kind = kind;
  }
  
  public int getKind()
  {
    return kind;
  }

  public void setAddress(int address)
  {
    this.address = address;
  }

  public int getAddress()
  {
    return address;
  }

  public void setChildren(Vector children)
  {
    this.children = children;
  }

  public Vector getChildren()
  {
    return children;
  }

  /**
   * Read Ast from LineReader.
   *
   * @param nodeTable
   * <ul>
   * <li> If nodeTable != null, each AST node in the file has a
   * unique address.  E.g., in a CFG file generated by RC </li>
   * <li> If nodeTable == null, no AST node in the file has addresses.
   *      For example, in FSA files describing security properties</li>
   * </ul> */
  public static Ast read(LineReader reader, Hashtable nodeTable)
    throws IOException
  {
    String str = reader.nextToken();

    if (str == null)
      return null;
    if (!str.equals("{"))
      Util.die("expect {", null, reader.lineno());
    return read0(reader, nodeTable);
  }

  /**
   * Read Ast from a String
   */
  public static Ast read(String buffer, Hashtable nodeTable)
    throws IOException
  {
    return read(new LineReader(new StringReader(buffer)), nodeTable);
  }

  protected static Ast read0(LineReader reader, Hashtable nodeTable)
    throws IOException
  {
    Ast ast, ast2;
    String str;
    Integer kindInteger, address;

    ast = new Ast();
    ast.children = new Vector();

    if (nodeTable != null)
    // Each AST has an address
    {
      // Read address
      address = new Integer(reader.nextInt());
      if (address.intValue() != 0)
      {
	if (nodeTable.get(address) != null)
          Util.warn(Util.ALERT,
		    "deny the duplicate AST address " + address,
		    null, reader.lineno());
        else
          nodeTable.put(address, ast);
	ast.address = address.intValue();
      }
    }
    
    // Read kind
    str = reader.nextToken();
    if (str == null)
      Util.die("expect an AST kind", null, reader.lineno());
    if ((kindInteger = (Integer)kindInt.get(str)) != null)
      ast.setKind(kindInteger.intValue());
    else
    {
      Util.warn(Util.WARNING,
		"unknown AST kind " + str, null, reader.lineno());
      ast.setKind(kind_unmatched);
    }

    // Read children
    for (str = reader.nextToken();
	 reader.getTtype() != StreamTokenizer.TT_EOF;
	 str = reader.nextToken())
    {
      if (str == null)
	Util.die("unexpected end of file", null, reader.lineno());
      else if (str.equals("}"))
	// End of current node
	break;
      else if (str.equals("{"))
      // Begins a new node
      {
	ast2 = read0(reader, nodeTable);
	ast.children.add(ast2);
      }
      else if (str.charAt(0) == pointerChar)
      // A pointer to an Ast
      {
	address = new Integer(str.substring(1));
	if (address.intValue() == 0)
	  Util.warn(Util.ALERT, "ignore a null AST reference", null,
		    reader.lineno());
	else if ((ast2 = (Ast)nodeTable.get(address)) == null)
	  Util.warn(Util.ALERT, "undefined AST reference " + address, null,
		    reader.lineno());
	else
	  ast.children.add(ast2);
      }
      else
        // A string
        ast.children.add(str);
    }

    return ast;
  }

  /**
   * Print this AST and all its children
   *
   * @param printAddress Whether to write the address of this Ast node
   * @param hashCode Stores all Ast objects that have been written out
   *                 so that one node is not written out more than once
   */
  public final void write(PrintWriter writer, boolean printAddress,
			  HashSet nodeHash)
  {
    int i;
    Integer code;
    Object child;
    String str;

    if (printAddress && nodeHash.contains(this))
    // We have printed this AST, so this time we only print a pointer to it.
    {
      writer.print(pointerChar);
      writer.print(address + " ");
      return;
    }
    writer.print("{ ");
    if (printAddress)
    {
      writer.print(address + " ");
      nodeHash.add(this);
    }
    writer.print(getKindLabel() + " ");
    if (children != null)
      for (i = 0; i < children.size(); i++)
      {
	child = children.get(i);
	if (child instanceof Ast)
	  ((Ast)child).write(writer, printAddress, nodeHash);
	else if (child instanceof String)
	{
	  writeEscape(writer, (String)child);
	  writer.print(' ');
	}
	else
	  Util.warn(Util.WARNING, "ignore the unknown AST object type " +
	  	     child.getClass().getName());
      }
    writer.print("} ");
  }
  
  /**
   * Escape certain characters to make StreamTokenizer happy
   */
  public static final void writeEscape(PrintWriter writer, String str)
  {
    int i, length;
    char ch;
    
    writer.print('"');
    length = str.length();
    for (i = 0; i < length; i++)
    {
      switch((ch = str.charAt(i)))
      {
	case '\n':
	  writer.print("\\n");
	  break;
	case '\r':
	  writer.print("\\r");
	  break;
	case '"':
	  writer.print("\\\"");
	  break;
	case '\\':
          writer.print("\\\\");
	  break;
	default:
	  writer.print(ch);
      }
    }
    writer.print('"');
  }

  /**
   * Write the AST to a dot file for visualization
   */
  public final void writeToDot(PrintWriter writer)
  {
    Vector nodeQueue, childQueue;
    HashSet nodeHash;
    Ast node, node2;
    Object child;
    int i;

    nodeQueue = new Vector();
    nodeHash = new HashSet();
    childQueue = new Vector();

    writer.println("digraph \"" + getKindLabel() + "\" {\nsize=\"8,11\";");
    nodeQueue.add(this);
    nodeHash.add(this);
    while (nodeQueue.size() > 0)
    {
      node = (Ast)nodeQueue.remove(0);
      writer.print(node.address + " [label=\"" + node.getKindLabel());
      for (i = 0; i < node.children.size(); i++)
      {
	child = node.children.get(i);
	if (child instanceof Ast)
	{
	  childQueue.add(child);
	  if (!nodeHash.contains(child))
	  {
	    nodeQueue.add(child);
	    nodeHash.add(child);
	  }
	}
	else if (child instanceof String)
	{
	  // need to escape the string.
	  //writer.print(' ');
	  //writeEscape(writer, (String)child);
	}
	else
	  Util.warn(Util.WARNING,
		    "unknown AST object type " + child.getClass().getName());
      }
      writer.println("\"]");
      for (i = 0; i < childQueue.size(); i++)
      {
	node2 = (Ast)childQueue.get(i);
	writer.println(node.address + " -> " + node2.address);
      }
      childQueue.clear();
    }
    writer.println("}");
    nodeHash.clear();    
  }
  
  public final String getKindLabel()
  {
    String str;
    if (kind < 0 || kind >= kindString.length)
      str = "unmatched";
    else
      str = kindString[kind];

    return str;
  }

  public final String toString()
  {
    StringWriter writer = new StringWriter();
    write(new PrintWriter(writer), false, null);
    writer.flush();
    return writer.toString();
  }

  /**
   * Match this AST against a list of pattern ASTs that are on all the
   * transitions from the same node in an FSA.
   *
   * @return The index of the first matched pattern.  If none of the
   * patterns match but one of them is of type kind_other, return its
   * index.  Otherwise, return -1 and warn, because in each FSA every
   * node is required to have a kind_other transition to itself which 
   * enables us to trace into user defined function.
   */
  public final int match(Vector patterns)
  {
    int otherIndex = -1, i;
    Ast pattern;
    
    for (i = 0; i < patterns.size(); i++)
    {
      pattern = (Ast)patterns.get(i);
      if (pattern.kind == kind_other)
      {
	if (otherIndex == -1)
	  otherIndex = i;
        else
	  Util.warn(Util.WARNING, 
	     "Ignore duplicate { other } ASTs from the same node: indice "
		    + i + " and " + otherIndex + ")");
      }
      else
      {
	if (match(pattern, null))
	{
	  //System.err.println("Matched: " + i + ": " + pattern.toString());
	  break;
	}
	else
	{
	  //Util.println("Failed to match " + this + " to " + pattern);
	}
      }
    }

    if (i < patterns.size())
    {
      return i;
    }
    else
    {
      if (otherIndex == -1)
	Util.warn(Util.WARNING, "Cannnot find { other } AST from this state");

      //System.err.println("Matched other");
      return otherIndex;
    }
  }

  /**
   * This method operates in two modes.
   * <ul>
   * <li>If <code>assignment==null</code>, determine if this AST
   * matches the AST <code>pattern</code>.  Note that if <code>pattern</code>
   * is a pattern variable, it matches this unconditionally to make
   * Cfg.hasUsefulAst() happy.  There should be a better way to handle this.
   * </li>
   * <li>If <code>assignment!=null</code>, determine if this AST
   * matches the AST <code>pattern</code>.  However, if
   * <code>pattern</code> contains pattern variables, try to find the
   * binding from the pattern variables to concrete variables in the program
   * and store the binding in <code>assignment</code>.
   *
   * @param pattern A regular or pattern AST
   * @param assignment If not null, contains bindings from pattern variables
   * in the FSA to concrete variables in the program.
   *
   * assignment:
   * Key: name of a pattern variable in the FSA.
   * Value: Vector of matched concrete variables in the program.
   */
  public final boolean match(Ast pattern, Hashtable assignment)
  {
    Object a, b;
    boolean comparison, isFound;
    Object lastChild;
    boolean hasEllipsis;
    int i, numToCompare;
    String variable;
    Ast ast;
    Vector asts;

    // Handle variable discovery
    if (pattern.kind == kind_var)
    {
      if (assignment == null)
	// this is so to make Cfg.hasUsefulAst() happy
	return true;
      variable = (String)pattern.children.get(0);
      if ((asts = (Vector)assignment.get(variable)) == null)
      {
	asts = new Vector();
	assignment.put(variable, asts);
      }
      // If the same variable appears in a pattern AST more than once,
      // then all of their instances in the concrete AST must match
      // each other.  E.g., if the pattern AST is f(x, x), then the
      // concrete AST f(3,3) matches, but the concrete AST f(3,2) does
      // not.
      //
      // June 9, 2002
      // The above comment is no longer valid.  I won't check for
      // consistent binding of each pattern variable in an AST here,
      // because I cannot check for consistent binding of each pattern
      // variable in all ASTs here anyway.  Instead, I leave
      // consistency checking to when a MetaFsa is instantiated, where
      // all instances of the same pattern variable will be replaced
      // by the same actual AST.
      // if (ast != null)
      //	return match(ast, null);
      asts.add(this);
      return true;
    }

    // kind_any matches any Ast or string
    if (pattern.kind == kind_any)
      return true;
    
    /* Handle the logical operators "not" and "or" */
    if (pattern.kind == kind_not)
    {
      if (pattern.children.size() != 1)
	Util.die("the operator 'not' must be followed by exactly one child in ASTs");
      return !match((Ast)pattern.children.get(0), assignment);
    }
    else if (pattern.kind == kind_or)
    {
      isFound = false;
      for (i = 0; i < pattern.children.size(); i++)
	if (match((Ast)pattern.children.get(i), assignment))
	{
	  if (assignment == null)
            return true;
	  else
	    isFound = true;
	}
      return isFound;
    }

    /* Match actual AST */
    if (kind != pattern.kind)
    {
      return false;
    }

    // Determine if two variables point to the same storage
    if (kind == kind_identifier)
    {
      // If both this Ast and the pattern Ast are variables (and therefore
      // contains ddecl) then compare ddecl only (ddecl points to the storage)
      if (pattern.children.size() >= 2 && children.size() >= 2)
	return (Ast)children.get(1) == (Ast)pattern.children.get(1);
      // Otherwise (both are not variables) compare their names only
      else
	return children.size() >= 1 && pattern.children.size() >= 1 &&
	  ((String)children.get(0)).equals((String)pattern.children.get(0));
    }
    
    // Determine if Ast pattern ends in an ellipsis
    hasEllipsis =
      (pattern.children.size() > 0) &&
      ((lastChild = pattern.children.get(pattern.children.size() - 1)) != null)
      && (lastChild instanceof Ast) &&
      (((Ast)lastChild).kind == kind_ellipsis);

    if ((hasEllipsis && children.size() < (pattern.children.size() - 1)) ||
	(!hasEllipsis && children.size() != pattern.children.size()))
      return false;

    numToCompare = pattern.children.size();
    if (hasEllipsis)
      numToCompare--;

    for (i = 0; i < numToCompare; i++)
    {
      a = children.get(i);
      b = pattern.children.get(i);
      if (a instanceof Ast && b instanceof Ast)
      {
        comparison = ((Ast)a).match((Ast)b, assignment);
      }
      else if (a instanceof String && b instanceof String)
      {
	comparison = ((String)a).equals((String)b);
      }
      else
	comparison = false;
      if (!comparison)
	return false;
    }
    
    return true;
  }

  /**
   * Determine whether two pattern Asts match
   */
  public final boolean patternMatch(Ast pattern)
  {
    int i;
    Object a, b;
    boolean comparison;
    
    if (kind != pattern.kind ||
	children.size() != pattern.children.size())
      return false;
	
    for (i = 0; i < children.size(); i++)
    {
      a = children.get(i);
      b = pattern.children.get(i);
      if (a instanceof Ast && b instanceof Ast)
      {
        comparison = ((Ast)a).patternMatch((Ast)b);
      }
      else if (a instanceof String && b instanceof String)
      {
	comparison = ((String)a).equals((String)b);
      }
      else
	comparison = false;
      if (! comparison)
	return false;
    }
    
    return true;
  }

  /**
   * Find all variables in this pattern Ast.
   *
   * @param variables Stores the variables found.  Key: variable name.
   * Value: Vector of pointers to where the variable appears in the
   * pattern Ast
   */
  public final void findVariable(Hashtable variables)
  {
    String name;
    Vector entry;
    int i;
    Object child;
    
    if (kind == kind_var)
    {
      name = (String)children.get(0);
      if ((entry = (Vector)variables.get(name)) == null)
      {
	entry = new Vector();
	variables.put(name, entry);
      }
      entry.add(this);
    }
    else
    {
      for (i = 0; i < children.size(); i++)
      {
	child = children.get(i);
	if (child instanceof Ast)
	  ((Ast)child).findVariable(variables);
      }
    }
  }

  /**
   * If this Ast is kind_funciton_call, return the function name
   */
  public final String getFunctionCallName()
  {
    Object child;
    
    if (kind != kind_function_call)
      return null;

    if ((child = children.get(0)) instanceof Ast &&
	((Ast)child).kind == kind_identifier)
      return (String)((Ast)child).children.get(0);
    else
      return null;
  }

  /**
   * Type of this AST
   */
  protected int kind;

  /**
   * Address of this AST in the CFG generated by rc
   */
  protected int address;

  /**
   * Children of this AST.  A child may be a String or an AST
   */
  protected Vector children;

  /**
   * Mapping symbolic kind to integer value
   */
  protected static final Hashtable kindInt = new Hashtable();

  /**
   * Leading character to denote an AST reference
   */
  public static final char pointerChar = '*';

  // generated by astjavagen.pl automatically
  public static final String[] kindString = new String[]
  {
    "toplevel_declarations",
    "toplevel_declaration",
    "asm_decl",
    "extension_decl",
    "ellipsis_decl",
    "data_decl",
    "parameter_declarations",
    "parameter_declaration",
    "function_decl",
    "data_declaration",
    "variable_decl",
    "declarator",
    "simple_declarator",
    "type_elements",
    "type_element",
    "typename",
    "typeof_expr",
    "typeof_type",
    "attribute",
    "rid",
    "qualifier",
    "tag_ref",
    "enumerators",
    "fields",
    "field_declaration",
    "field_extension_decl",
    "field_data_decl",
    "field_decl",
    "enumerator",
    "parameters",
    "parameter",
    "asttype",
    "word",
    "expressions",
    "expression",
    "comma",
    "sizeof_type",
    "alignof_type",
    "label_address",
    "cast",
    "cast_list",
    "conditional",
    "identifier",
    "compound_expr",
    "function_call",
    "array_ref",
    "field_ref",
    "unary",
    "binary",
    "signed_cst",
    "unsigned_cst",
    "lexical_cst",
    "string",
    "regionof",
    "regionof_name",
    "regionof_closure",
    "nelements",
    "adjust_rc",
    "update_rc",
    "global_rc",
    "adjust_function_decl",
    "update_function_decl",
    "adjustarray_function_decl",
    "rc_fn",
    "rc_fns",
    "init_list",
    "init_index",
    "init_field",
    "statement",
    "compound_stmt",
    "compound_declarations",
    "compound_declaration",
    "asm_stmt",
    "asm_stmt_plain",
    "asm_operands",
    "asm_operand",
    "if_stmt",
    "labeled_stmt",
    "expression_stmt",
    "while_stmt",
    "dowhile_stmt",
    "switch_stmt",
    "for_stmt",
    "break_stmt",
    "continue_stmt",
    "return_stmt",
    "goto_stmt",
    "computed_goto_stmt",
    "empty_stmt",
    "label",
    "id_label",
    "case_label",
    "default_label",
    "dummy",
    "other",

    // pattern kinds
    // boolean and relational operators
    "not",
    "or",
    "any",
    "ellipsis",
    
    // pattern variable
    "var",
  };

  public static final int
    kind_toplevel_declarations = 0,
    kind_toplevel_declaration = 1,
    kind_asm_decl = 2,
    kind_extension_decl = 3,
    kind_ellipsis_decl = 4,
    kind_data_decl = 5,
    kind_parameter_declarations = 6,
    kind_parameter_declaration = 7,
    kind_function_decl = 8,
    kind_data_declaration = 9,
    kind_variable_decl = 10,
    kind_declarator = 11,
    kind_simple_declarator = 12,
    kind_type_elements = 13,
    kind_type_element = 14,
    kind_typename = 15,
    kind_typeof_expr = 16,
    kind_typeof_type = 17,
    kind_attribute = 18,
    kind_rid = 19,
    kind_qualifier = 20,
    kind_tag_ref = 21,
    kind_enumerators = 22,
    kind_fields = 23,
    kind_field_declaration = 24,
    kind_field_extension_decl = 25,
    kind_field_data_decl = 26,
    kind_field_decl = 27,
    kind_enumerator = 28,
    kind_parameters = 29,
    kind_parameter = 30,
    kind_asttype = 31,
    kind_word = 32,
    kind_expressions = 33,
    kind_expression = 34,
    kind_comma = 35,
    kind_sizeof_type = 36,
    kind_alignof_type = 37,
    kind_label_address = 38,
    kind_cast = 39,
    kind_cast_list = 40,
    kind_conditional = 41,
    kind_identifier = 42,
    kind_compound_expr = 43,
    kind_function_call = 44,
    kind_array_ref = 45,
    kind_field_ref = 46,
    kind_unary = 47,
    kind_binary = 48,
    kind_signed_cst = 49,
    kind_unsigned_cst = 50,
    kind_lexical_cst = 51,
    kind_string = 52,
    kind_regionof = 53,
    kind_regionof_name = 54,
    kind_regionof_closure = 55,
    kind_nelements = 56,
    kind_adjust_rc = 57,
    kind_update_rc = 58,
    kind_global_rc = 59,
    kind_adjust_function_decl = 60,
    kind_update_function_decl = 61,
    kind_adjustarray_function_decl = 62,
    kind_rc_fn = 63,
    kind_rc_fns = 64,
    kind_init_list = 65,
    kind_init_index = 66,
    kind_init_field = 67,
    kind_statement = 68,
    kind_compound_stmt = 69,
    kind_compound_declarations = 70,
    kind_compound_declaration = 71,
    kind_asm_stmt = 72,
    kind_asm_stmt_plain = 73,
    kind_asm_operands = 74,
    kind_asm_operand = 75,
    kind_if_stmt = 76,
    kind_labeled_stmt = 77,
    kind_expression_stmt = 78,
    kind_while_stmt = 79,
    kind_dowhile_stmt = 80,
    kind_switch_stmt = 81,
    kind_for_stmt = 82,
    kind_break_stmt = 83,
    kind_continue_stmt = 84,
    kind_return_stmt = 85,
    kind_goto_stmt = 86,
    kind_computed_goto_stmt = 87,
    kind_empty_stmt = 88,
    kind_label = 89,
    kind_id_label = 90,
    kind_case_label = 91,
    kind_default_label = 92,
    kind_dummy = 93,
    kind_other = 94,

    // pattern kinds
    kind_min_pattern = 95,
    kind_not = 95,
    kind_or = 96,
    kind_any = 97,
    kind_ellipsis = 98,
    kind_var = 99,
    kind_max_pattern = 99,

    kind_unmatched = 100;

  static
  {
    int i;

    for (i = 0; i < kindString.length; i++)
    {
      kindInt.put(kindString[i], new Integer(i));
    }
  }
}
