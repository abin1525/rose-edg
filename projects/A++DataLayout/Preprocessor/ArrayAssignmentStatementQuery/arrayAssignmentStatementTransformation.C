#include "arrayPreprocessor.h"

// *****************************************************************
//      Interface function for Array Assignment Statement Query
// *****************************************************************

using namespace SageInterface;
using namespace SageBuilder;

bool ArrayAssignmentStatementTransformation::targetForTransformation(SgNode* astNode) {
	// This is a static function which returns true when the current node
	// of the AST is a target for transformation.
	bool returnValue = FALSE;

	ROSE_ASSERT (astNode != NULL);

	// This code used to recognize array statements checks to see if the name of the type of the
	// function contained in the expression statement is "doubleArray".  This code will be
	// dramatically simplified once we can use the higher level grammars to recognise array
	// statements.  At present this code is not a robust test for the use existence of a transformable
	// array statement it will be robust once we can use the higher level grammars (AST restructuring
	// tools) generated by ROSETTA.

	SgExprStatement *expressionStatement = isSgExprStatement(astNode);

	// In this example we only perform transformations on declaration statements
	if (expressionStatement != NULL)
	{
		SgExpression* expression = expressionStatement->get_expression();
		ROSE_ASSERT (expression != NULL);

		// See if this is an A++ member function call
		SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(expression);
		// ROSE_ASSERT (functionCallExp != NULL);

		if (functionCallExp != NULL)
		{
			SgType* type = functionCallExp->get_type();
			ROSE_ASSERT (type != NULL);
			SgClassType* classType = isSgClassType(type);
			if (classType == NULL)
			{
				// Check to see if it a reference to a class type (and get it's base type)
				SgType* type = functionCallExp->get_type();
				ROSE_ASSERT (type != NULL);
				SgReferenceType* referenceType = isSgReferenceType(type);
				if (referenceType != NULL)
				{
					ROSE_ASSERT (referenceType != NULL);
					SgType* baseType = referenceType->get_base_type();
					ROSE_ASSERT (baseType != NULL);
					classType = isSgClassType(baseType);
					ROSE_ASSERT (classType != NULL);
				} else {
					return FALSE;
				}
			}
			ROSE_ASSERT (classType != NULL);

			// It is the get_name which returns the type name (not the qualified name (I forget what it is for)
			SgName name = classType->get_name();
			if (name == "intArray" || name == "floatArray" || name == "doubleArray") {
#if DEBUG
				printf(
						"ArrayAssignmentStatementTransformation::targetForTransformation Expression Statement %s \n",
						expressionStatement->unparseToString().c_str());
#endif
				returnValue = TRUE;
			} else {
				printf(
						"Not a expression statement containing a function call expression of type {double,float,int}Array ... \n");
			}
		} else {
			// This case could be "A;" in which case there is no transformation
			printf("Not a expression statement containing a function call expression ... \n");
		}
	} else {
		// printf ("Not an expression statement (only expression statements qualify!) \n");
	}

	return returnValue;
}

void ArrayAssignmentStatementTransformation::createVariableDeclarations(SgExprStatement* exprStatement, int dimension) {
	int i = 0;

	for (i = dimension; i > 0; i--) {
		string dimStr = StringUtility::numberToString(i);
		string index = "_" + dimStr;
		string length = "_length" + dimStr;

#if DEBUG
		cout << "Index: " << index << " Length: " << length << endl;
#endif

		SgVariableDeclaration* indexDecl = buildVariableDeclaration(index, buildIntType());
		SgVariableDeclaration* lengthDecl = buildVariableDeclaration(length, buildIntType());

		insertStatementBefore(getFirstStatement(getEnclosingFunctionDefinition(exprStatement, false), false),
				indexDecl);
		insertStatementBefore(getFirstStatement(getEnclosingFunctionDefinition(exprStatement, false), false),
				lengthDecl);
	}
}

// Static function (interface function)
ArrayAssignmentStatementQuerySynthesizedAttributeType ArrayAssignmentStatementTransformation::transformation(
		const ArrayStatementQueryInheritedAttributeType & X, SgNode* astNode) {

#if DEBUG
	printf (" Top of ArrayAssignmentStatementTransformation::transformation \n");
#endif

	// This function returns the string representing the array statement transformation
	ROSE_ASSERT (isSgExprStatement(astNode) != NULL);

	// Pass in the ArrayStatementQueryInheritedAttributeType object so
	// that all previously visited scopes can be copied to the new
	// inherited attribute.
	ArrayAssignmentStatementQueryInheritedAttributeType arrayAssignmentStatementQueryInheritedData(X, astNode);
	list<int> & transformationOptions = arrayAssignmentStatementQueryInheritedData.getTransformationOptions();

	// Find all the hints specified as enum values constructor parameters for declarations of
	// variables of type "TransformationAssertion".  The current scope and all parent scopes are
	// searched back to the global scope. (Maybe this should return a value rather than modify a
	// reference parameter???)
	TransformationSupport::getTransformationOptions(astNode, transformationOptions, "TransformationAssertion");

#if DEBUG
	printf(" In ArrayAssignmentStatementTransformation::transformation (Need to handle indexObjectNameStringList) ");
#endif

	// Generate a list of names of variables of type InternalIndex
	// Kamal (07/21/2011) Check later to see if the list is still needed
	Rose_STL_Container < string > indexObjectNameStringList = NameQuery::querySubTree(astNode, "InternalIndex",
			NameQuery::VariableNamesWithTypeName);

	// Now use STL to build a list of unique names
	//indexObjectNameStringList.unique();

	// If Index objects are used in the array statement then we want to use special indexing based
	// substript computation and we need to communicate this to all phases of the transformation
	// (through use of an inherited attribute!).
	// ROSE_ASSERT (arrayAssignmentStatementQueryInheritedData.getUsingIndexObjectsInSubscriptComputation() == FALSE);
	if (indexObjectNameStringList.size() > 0)
		arrayAssignmentStatementQueryInheritedData.setUsingIndexObjectsInSubscriptComputation(true);
	else
		arrayAssignmentStatementQueryInheritedData.setUsingIndexObjectsInSubscriptComputation(false);

	// The dimension of the array statement must be computed on the way down (in the traversal of the AST).
	// This query gets the list of integer associated with the dimension of each array operand (array
	// operands using the doubleArray::operator() member function).

#if DEBUG
	cout << " Checking queryNumberOfArgsInParenthesisOperator " << astNode->unparseToString() << astNode->class_name() << " Variant: " << astNode->variantT() << " " << V_SgExprListExp << " " << V_SgFunctionCallExp << endl;
#endif

	vector<SgFunctionCallExp*> functionExpList = querySubTree<SgFunctionCallExp>(astNode, V_SgFunctionCallExp);
	SgFunctionCallExp* functionCall;
	Rose_STL_Container<int> operandDimensionList;
	for (vector<SgFunctionCallExp*>::iterator iter = functionExpList.begin(); iter != functionExpList.end(); iter++) {
		string operatorName = TransformationSupport::getFunctionName(*iter);

#if DEBUG
		cout << " Arg List Size: " << (*iter)->get_args()->get_expressions().size() << " " << TransformationSupport::getFunctionName ( *iter ) << endl;
#endif

		if (operatorName == "operator()") {
			operandDimensionList.push_back((*iter)->get_args()->get_expressions().size());
			break;
		}
	}

#if DEBUG
	printf(" operandDimensionList size : %d \n", operandDimensionList.size());
#endif

	// If there is no dimension computed for the query then it means that there were no operator()
	// used in which case we have to assume 6D array operations
	int dimensionOfArrayStatement = (operandDimensionList.size() == 0) ? 6 : *(operandDimensionList.begin());

#if DEBUG
	printf("Array statement is %d dimensional \n", dimensionOfArrayStatement);
	printf("arrayAssignmentStatementQueryInheritedData.arrayStatementDimension = %d \n",
			arrayAssignmentStatementQueryInheritedData.arrayStatementDimension);
#endif

	// Make sure that it has the default value before we change it (error checking)
	ROSE_ASSERT (arrayAssignmentStatementQueryInheritedData.arrayStatementDimension == -1);

	// Modify the inherited attribute using the array statement dimension data
	arrayAssignmentStatementQueryInheritedData.arrayStatementDimensionDefined = TRUE;
	arrayAssignmentStatementQueryInheritedData.arrayStatementDimension = dimensionOfArrayStatement;

#if DEBUG
	printf("(after search for array statement dimension = %d) ... \n", dimensionOfArrayStatement);
#endif

	// Build a transformation object so we can setup the accumulatorValue which is not a static data
	// member.  Other transformations which don't use an accumulatorValue attribute don't require this
	// step.
	ArrayAssignmentStatementTransformation transformation;

	// Build a return value for the transformation function
	ArrayAssignmentStatementQuerySynthesizedAttributeType returnArrayStatementTransformation(astNode);

	// WARNING: It is a design problem that we have the dimension set in two locations
	// Set the dimension of the array statement in the array operand database
	transformation.accumulatorValue.operandDataBase.setDimension(dimensionOfArrayStatement);
	ROSE_ASSERT (transformation.accumulatorValue.operandDataBase.getDimension() > 0);

	// Setup the data base with the options specified by the use and extracted from the current scope
	// of the application code.
	transformation.accumulatorValue.operandDataBase.setUserOptimizationAssertions(
			arrayAssignmentStatementQueryInheritedData.transformationOptions);
	ROSE_ASSERT ( transformation.accumulatorValue.operandDataBase.transformationOption >
			ArrayTransformationSupport::UnknownIndexingAccess );

	// Make sure the data base has been setup properly
	ROSE_ASSERT ( transformation.accumulatorValue.operandDataBase.transformationOption >
			ArrayTransformationSupport::UnknownIndexingAccess );
	ROSE_ASSERT ( transformation.accumulatorValue.operandDataBase.dimension > -1 );

	// Call the tree traversal mechanism (tree walker)
	returnArrayStatementTransformation = transformation.traverse(astNode, arrayAssignmentStatementQueryInheritedData);

#if DEBUG
	printf ("(after ASSIGNMENT TRANSFORMATION QUERY) ... \n");
#endif

	return returnArrayStatementTransformation;
}

// ********************************************************************************************
//                             Destructors and Constructors
// ********************************************************************************************

ArrayAssignmentStatementTransformation::~ArrayAssignmentStatementTransformation() {
	// Nothing to do here!
	delete &accumulatorValue;
}
;

ArrayAssignmentStatementTransformation::ArrayAssignmentStatementTransformation() : // Initialize the accumulator attribute
		accumulatorValue(*(new ArrayAssignmentStatementQueryAccumulatorType())) {
	// Nothing to do here!
	printf(
			"ERROR: Can't call this default constructor for ArrayAssignmentStatementTransformation: SgProject information for base class invalid pointer \n");
	//ROSE_ABORT();
}
;

// ********************************************************************************************
//                                         Data Base Support 
// ********************************************************************************************

OperandDataBaseType &
ArrayAssignmentStatementTransformation::getOperandDataBase() {
	// return operandDataBase;
	return accumulatorValue.operandDataBase;
}

